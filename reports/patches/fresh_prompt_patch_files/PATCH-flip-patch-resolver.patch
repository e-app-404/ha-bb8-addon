## 2) Make the test flip—patch the resolver itself

Please ensure:

We’ll control the module used by the dispatcher by patching `_get_scanner_module` to return a stub with a MagicMock. This completely removes import-order ambiguity.

### Patch `tests/test_discovery_publisher.py` (only the failing test)

```python
from types import SimpleNamespace
from unittest.mock import patch, MagicMock
import os, importlib

def test_scanner_only_discovery_when_bridge_telemetry_enabled():
    os.environ["ENABLE_BRIDGE_TELEMETRY"] = "1"

    stub_scanner = SimpleNamespace(publish_discovery=MagicMock(name="publish_discovery"))

    # Patch the resolver BEFORE importing the dispatcher so the dispatcher uses our stub
    with patch("bb8_core.mqtt_dispatcher._get_scanner_module", return_value=stub_scanner), \
         patch("bb8_core.mqtt_dispatcher.publish_discovery") as mock_dispatcher:
        md = importlib.import_module("bb8_core.mqtt_dispatcher")
        md.start_mqtt_dispatcher(controller=MagicMock())

        mock_dispatcher.assert_not_called()
        assert stub_scanner.publish_discovery.called, "scanner publish_discovery was not called"
```

No top-level imports; keep them inside the context manager.
(And keep `tests/conftest.py` setting `MQTT_HOST=127.0.0.1` at the top of file as you have it.)

---
