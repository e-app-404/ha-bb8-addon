
diff --git a/bb8_core/mqtt_dispatcher.py b/bb8_core/mqtt_dispatcher.py
index f4a2b77..a9b63f4 100644
--- a/bb8_core/mqtt_dispatcher.py
+++ b/bb8_core/mqtt_dispatcher.py
@@ -1,10 +1,11 @@
 from __future__ import annotations

 import logging
-from typing import Any, Optional, Tuple, Callable, List
+from typing import Any, Optional, Tuple, Callable, List
 from .addon_config import CONFIG, CONFIG_SOURCE, init_config
 import json
 from .common import CMD_TOPICS, STATE_TOPICS
+from ipaddress import ip_address

 log = logging.getLogger(__name__)
 _LOOPBACKS = {"localhost", "127.0.0.1"}
@@
 _RESUB_ON_CONNECT_ATTACHED = False
+_DISCOVERY_PUBLISHED = False

@@
 def _compute_key(
     host: Any, port: Any, topic: Any, client_id: Any, username: Any
 ) -> Tuple[str, int, str, str, bool]:
     return (str(host), int(port), str(topic), str(client_id), bool(username))

+def _is_loopback(h: str) -> bool:
+    try:
+        if h in _LOOPBACKS:
+            return True
+        return ip_address(h).is_loopback  # handles ::1 etc.
+    except Exception:
+        return False
+
+def _canonicalize_params(host: Optional[str], port: Optional[int],
+                         topic: Optional[str], client_id: Optional[str],
+                         username: Optional[str], password: Optional[str]
+                         ) -> Tuple[str,int,str,str,Optional[str],Optional[str],str]:
+    """
+    Resolve final MQTT params with precedence:
+      explicit kwargs > CONFIG > fallback.
+    If a caller passes loopback while CONFIG has non-loopback, override to CONFIG.
+    Returns (host, port, topic, client_id, username, password, source_tag)
+    """
+    init_config()  # ensure CONFIG is fresh
+    cfg_host  = CONFIG.get("MQTT_HOST") or CONFIG.get("mqtt_broker") or "127.0.0.1"
+    cfg_port  = int(CONFIG.get("MQTT_PORT") or CONFIG.get("mqtt_port") or 1883)
+    cfg_topic = CONFIG.get("MQTT_BASE") or CONFIG.get("mqtt_topic_prefix") or "bb8"
+    cfg_cid   = CONFIG.get("mqtt_client_id") or "bb8_presence_scanner"
+    cfg_user  = CONFIG.get("MQTT_USERNAME") or CONFIG.get("mqtt_username")
+    cfg_pass  = CONFIG.get("MQTT_PASSWORD") or CONFIG.get("mqtt_password")
+
+    use_host  = host  if host  is not None else cfg_host
+    use_port  = int(port if port is not None else cfg_port)
+    use_topic = topic if topic is not None else cfg_topic
+    use_cid   = client_id if client_id is not None else cfg_cid
+    use_user  = username
+    use_pass  = password
+    src = "kwargs"
+
+    # Fill creds from CONFIG if not explicitly passed
+    if use_user is None and cfg_user is not None:
+        use_user, src = cfg_user, "config"
+    if use_pass is None and cfg_pass is not None:
+        use_pass, src = cfg_pass, "config"
+
+    # If caller passed loopback but CONFIG has a non-loopback host, override.
+    if _is_loopback(use_host) and not _is_loopback(cfg_host):
+        use_host, src = cfg_host, "override_from_config"
+
+    return use_host, use_port, use_topic, use_cid, use_user, use_pass, src
+
@@
 _orig_start_mqtt_dispatcher = None
 try:
     _orig_start_mqtt_dispatcher = start_mqtt_dispatcher  # type: ignore[name-defined]
 except Exception:
     _orig_start_mqtt_dispatcher = None
@@
 def _guarded_start_mqtt_dispatcher(
-    *, mqtt_host: Optional[str] = None, mqtt_port: Optional[int] = None,
-    mqtt_topic: Optional[str] = None, client_id: Optional[str] = None,
-    username: Optional[str] = None, password: Optional[str] = None, **kwargs: Any
+    *, mqtt_host: Optional[str] = None, mqtt_port: Optional[int] = None,
+    mqtt_topic: Optional[str] = None, client_id: Optional[str] = None,
+    username: Optional[str] = None, password: Optional[str] = None, **kwargs: Any
 ):
-    host = mqtt_host or CONFIG.get("MQTT_HOST") or CONFIG.get("mqtt_broker") or "localhost"
-    port = int(mqtt_port if mqtt_port is not None else (CONFIG.get("MQTT_PORT") or CONFIG.get("mqtt_port") or 1883))
-    topic = mqtt_topic or CONFIG.get("MQTT_BASE") or CONFIG.get("mqtt_topic_prefix") or "bb8"
-    cid = client_id or CONFIG.get("mqtt_client_id") or "bb8-addon"
-    user = username if username is not None else (CONFIG.get("MQTT_USERNAME") or CONFIG.get("mqtt_username"))
-    pwd = password if password is not None else (CONFIG.get("MQTT_PASSWORD") or CONFIG.get("mqtt_password"))
+    host, port, topic, cid, user, pwd, src = _canonicalize_params(
+        mqtt_host, mqtt_port, mqtt_topic, client_id, username, password
+    )

     key = _compute_key(host, port, topic, cid, user)
     if is_dispatcher_started():
         if key != _START_KEY:
             log.warning("dispatcher already started with %s, ignoring new start %s", _START_KEY, key)
             return False
         return True

-    log.info("Dispatcher config (resolved): host=%s port=%s user=%s topic=%s client_id=%s source=%s",
-             host, port, bool(user), topic, cid, CONFIG_SOURCE or "unknown")
+    # Use availability topic for clarity in logs
+    avail_t = CONFIG.get("availability_topic_scanner", f"{CONFIG.get('MQTT_BASE','bb8')}/availability/scanner")
+    log.info(
+        "Dispatcher config (resolved): host=%s port=%s user=%s topic=%s client_id=%s availability_topic=%s source=%s",
+        host, port, bool(user), topic, cid, avail_t, src
+    )

     res = _orig_start_mqtt_dispatcher(  # type: ignore[misc]
         mqtt_host=host,
         mqtt_port=port,
         mqtt_topic=topic,
         client_id=cid,
         username=user,
         password=pwd,
         **kwargs,
     )
@@
     _apply_pending_subscriptions()
-    _attach_on_connect_resubscribe()
+    _attach_on_connect_resubscribe()
     # Publish discovery once, if enabled
-    _maybe_publish_bb8_discovery()
+    _maybe_publish_bb8_discovery()
     return res
@@
 def _attach_on_connect_resubscribe() -> None:
@@
-    def _on_connect(client, userdata, flags, rc, properties=None):  # paho v5 sig compatible
-        log.info("mqtt_on_connect rc=%s; re-binding subscriptions (%d topics)", rc, len(_BOUND_TOPICS) + len(_PENDING_SUBS))
-        _apply_pending_subscriptions()
+    def _on_connect(client, userdata, flags, rc, properties=None):  # paho v5 sig compatible
+        log.info("mqtt_on_connect rc=%s; re-binding subscriptions (%d topics)", rc, len(_BOUND_TOPICS) + len(_PENDING_SUBS))
+        _apply_pending_subscriptions()
+        # Publish discovery at-connect to avoid races where client wasn't ready earlier
+        _maybe_publish_bb8_discovery()
@@
 def _maybe_publish_bb8_discovery() -> None:
-    if not CONFIG.get("dispatcher_discovery_enabled", False):
+    global _DISCOVERY_PUBLISHED
+    if _DISCOVERY_PUBLISHED:
+        return
+    if not CONFIG.get("dispatcher_discovery_enabled", False):
         return
     if CLIENT is None:
         return
     def _pub(topic: str, payload: str, retain: bool) -> None:
         CLIENT.publish(topic, payload=payload, qos=int(CONFIG.get("qos",1)), retain=retain)
     publish_bb8_discovery(_pub)
+    _DISCOVERY_PUBLISHED = True
+    log.info("Published discovery: all canonical entities (retained)")
