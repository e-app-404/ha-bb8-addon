diff --git a/bb8_core/ble_link.py b/bb8_core/ble_link.py
index c4d1ff2..e9a7bc1 100644
--- a/bb8_core/ble_link.py
+++ b/bb8_core/ble_link.py
@@ -1,11 +1,12 @@
 from __future__ import annotations

 import asyncio
 import logging
 from concurrent.futures import Future
-from typing import Optional, Any, Coroutine, TypeVar
+from typing import Optional, Any, Coroutine, TypeVar, List

 log = logging.getLogger(__name__)

 T = TypeVar("T")
 # Dedicated loop supplied by bridge_controller.
 _loop: Optional[asyncio.AbstractEventLoop] = None
 _runner_future: Optional[Future] = None
 _started: bool = False
@@ -39,6 +40,28 @@ async def _run() -> None:
         log.info("BLE worker cancelled; shutting down cleanly.")
         raise

+
+async def _cancel_and_drain() -> int:
+    """
+    Cancel and await completion of all pending tasks on the BLE loop.
+    Must be executed *inside* the BLE loop.
+    Returns the number of tasks cancelled.
+    """
+    current = asyncio.current_task()
+    # Snapshot all tasks bound to this loop
+    pending: List[asyncio.Task[Any]] = [
+        t for t in asyncio.all_tasks()
+        if t is not current and not t.done()
+    ]
+    for t in pending:
+        t.cancel()
+    if pending:
+        results = await asyncio.gather(*pending, return_exceptions=True)
+        excs = [r for r in results if isinstance(r, Exception)]
+        if excs:
+            log.debug("BLE cleanup gathered %d exception(s): %s",
+                      len(excs), ", ".join(type(e).__name__ for e in excs))
+    return len(pending)
+

 def start() -> None:
     """Idempotently start the BLE worker on the dedicated loop."""
     global _runner_future, _started
     if _started:
@@ -52,14 +75,27 @@ def start() -> None:
     _started = True
     log.info("BLE link runner started.")

-
-def stop(timeout: float = 2.5) -> None:
+def stop(timeout: float = 2.5) -> None:
     """Cancel the BLE worker and wait for clean shutdown."""
     global _runner_future, _started
     fut = _runner_future
     _runner_future = None
     _started = False
     if fut and not fut.done():
         fut.cancel()
         try:
             fut.result(timeout=timeout)
         except asyncio.CancelledError:
             pass
         except Exception as exc:  # noqa: BLE001
             log.warning("BLE runner stop wait raised: %s", exc)
+    # New: drain any other pending tasks still attached to the BLE loop.
+    if _loop is not None:
+        try:
+            drained = asyncio.run_coroutine_threadsafe(
+                _cancel_and_drain(), _loop
+            ).result(timeout=timeout)
+            log.info("BLE cleanup: cancelled %d pending task(s).", drained)
+        except asyncio.TimeoutError:
+            log.warning("BLE cleanup timed out after %.2fs.", timeout)
+        except Exception as exc:  # noqa: BLE001
+            log.warning("BLE cleanup wait raised: %s", exc)


 def run_coro(coro: Coroutine[Any, Any, T]) -> Future[T]:
     """Schedule an awaitable on the dedicated BLE loop."""
     if _loop is None:
         raise RuntimeError("BLE loop not set; call set_loop() first")
     return asyncio.run_coroutine_threadsafe(coro, _loop)
