I001 [*] Import block is un-sorted or un-formatted
 --> app/test_ble_adapter.py:1:1
  |
1 | import os
  | ^^^^^^^^^
2 |
3 | def check_ble_adapter():
  |
help: Organize imports

E501 Line too long (89 > 88)
 --> app/test_ble_adapter.py:5:89
  |
3 | def check_ble_adapter():
4 |     # Check for BLE device node
5 |     hci_found = any(dev.startswith('hci') for dev in os.listdir('/sys/class/bluetooth/'))
  |                                                                                         ^
6 |
7 |     if hci_found:
  |

E501 Line too long (109 > 88)
 --> bb8_ascii_templates.py:1:89
  |
1 | def render_bb8_status(ts, model, identifier, rssi, uuid, paired=None, bonded=None, tx_power=None, path=None):
  |                                                                                         ^^^^^^^^^^^^^^^^^^^^^
2 |     # Use N/A for missing values
3 |     paired_str = f"{paired}" if paired is not None else "N/A"
  |

I001 [*] Import block is un-sorted or un-formatted
 --> bb8_core/__init__.py:3:1
  |
1 |   # bb8_core package
2 |
3 | / from .core import Core
4 | | from .ble_gateway import BleGateway
5 | | from .ble_bridge import BLEBridge
  | |_________________________________^
6 |   # from .facade import Bb8Facade  # Uncomment if present
  |
help: Organize imports

I001 [*] Import block is un-sorted or un-formatted
  --> bb8_core/addon_config.py:5:1
   |
 4 |   """
 5 | / from __future__ import annotations
 6 | | from typing import TYPE_CHECKING
 7 | | import os, json, yaml, logging
 8 | | from typing import Dict, Tuple
 9 | | from .types import (
10 | |     BridgeController,
11 | |     BLELink,
12 | |     MqttClient,
13 | |     BoolCallback,
14 | |     IntCallback,
15 | |     OptIntCallback,
16 | |     RGBCallback,
17 | | )
   | |_^
18 |   if TYPE_CHECKING:
19 |       from .bridge_controller import BridgeController as _BridgeControllerHint
   |
help: Organize imports

E401 [*] Multiple imports on one line
 --> bb8_core/addon_config.py:7:1
  |
5 | from __future__ import annotations
6 | from typing import TYPE_CHECKING
7 | import os, json, yaml, logging
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
8 | from typing import Dict, Tuple
9 | from .types import (
  |
help: Split imports

F401 [*] `.types.BridgeController` imported but unused
  --> bb8_core/addon_config.py:10:5
   |
 8 | from typing import Dict, Tuple
 9 | from .types import (
10 |     BridgeController,
   |     ^^^^^^^^^^^^^^^^
11 |     BLELink,
12 |     MqttClient,
   |
help: Remove unused import

F401 [*] `.types.BLELink` imported but unused
  --> bb8_core/addon_config.py:11:5
   |
 9 | from .types import (
10 |     BridgeController,
11 |     BLELink,
   |     ^^^^^^^
12 |     MqttClient,
13 |     BoolCallback,
   |
help: Remove unused import

F401 [*] `.types.MqttClient` imported but unused
  --> bb8_core/addon_config.py:12:5
   |
10 |     BridgeController,
11 |     BLELink,
12 |     MqttClient,
   |     ^^^^^^^^^^
13 |     BoolCallback,
14 |     IntCallback,
   |
help: Remove unused import

F401 [*] `.types.BoolCallback` imported but unused
  --> bb8_core/addon_config.py:13:5
   |
11 |     BLELink,
12 |     MqttClient,
13 |     BoolCallback,
   |     ^^^^^^^^^^^^
14 |     IntCallback,
15 |     OptIntCallback,
   |
help: Remove unused import

F401 [*] `.types.IntCallback` imported but unused
  --> bb8_core/addon_config.py:14:5
   |
12 |     MqttClient,
13 |     BoolCallback,
14 |     IntCallback,
   |     ^^^^^^^^^^^
15 |     OptIntCallback,
16 |     RGBCallback,
   |
help: Remove unused import

F401 [*] `.types.OptIntCallback` imported but unused
  --> bb8_core/addon_config.py:15:5
   |
13 |     BoolCallback,
14 |     IntCallback,
15 |     OptIntCallback,
   |     ^^^^^^^^^^^^^^
16 |     RGBCallback,
17 | )
   |
help: Remove unused import

F401 [*] `.types.RGBCallback` imported but unused
  --> bb8_core/addon_config.py:16:5
   |
14 |     IntCallback,
15 |     OptIntCallback,
16 |     RGBCallback,
   |     ^^^^^^^^^^^
17 | )
18 | if TYPE_CHECKING:
   |
help: Remove unused import

F401 [*] `.bridge_controller.BridgeController` imported but unused
  --> bb8_core/addon_config.py:19:56
   |
17 | )
18 | if TYPE_CHECKING:
19 |     from .bridge_controller import BridgeController as _BridgeControllerHint
   |                                                        ^^^^^^^^^^^^^^^^^^^^^
20 |
21 | LOG = logging.getLogger(__name__)
   |
help: Remove unused import: `.bridge_controller.BridgeController`

E402 Module level import not at top of file
  --> bb8_core/addon_config.py:36:1
   |
36 | from pathlib import Path
   | ^^^^^^^^^^^^^^^^^^^^^^^^
37 |
38 | def _load_yaml_cfg() -> Dict:
   |

I001 [*] Import block is un-sorted or un-formatted
  --> bb8_core/addon_config.py:36:1
   |
36 | from pathlib import Path
   | ^^^^^^^^^^^^^^^^^^^^^^^^
37 |
38 | def _load_yaml_cfg() -> Dict:
   |
help: Organize imports

N806 Variable `CANDIDATE_PATHS` in function should be lowercase
  --> bb8_core/addon_config.py:40:5
   |
38 | def _load_yaml_cfg() -> Dict:
39 |     # Candidate search paths with HA-first priority
40 |     CANDIDATE_PATHS = [
   |     ^^^^^^^^^^^^^^^
41 |         Path("/config/config.yaml"),
42 |         Path("/addons/local/beep_boop_bb8/config.yaml"),
   |

F841 Local variable `loaded_config` is assigned to but never used
  --> bb8_core/addon_config.py:48:5
   |
46 |     ]
47 |
48 |     loaded_config = None
   |     ^^^^^^^^^^^^^
49 |     source_path = None
   |
help: Remove assignment to unused variable `loaded_config`

F841 Local variable `source_path` is assigned to but never used
  --> bb8_core/addon_config.py:56:17
   |
54 |                 with path.open("r", encoding="utf-8") as f:
55 |                     yml = yaml.safe_load(f) or {}
56 |                 source_path = path
   |                 ^^^^^^^^^^^
57 |                 LOG.info(f"[CONFIG] Loaded config from: {path}")
58 |                 if isinstance(yml, dict) and "options" in yml and isinstance(yml["options"], dict):
   |
help: Remove assignment to unused variable `source_path`

E501 Line too long (99 > 88)
  --> bb8_core/addon_config.py:58:89
   |
56 |                 source_path = path
57 |                 LOG.info(f"[CONFIG] Loaded config from: {path}")
58 |                 if isinstance(yml, dict) and "options" in yml and isinstance(yml["options"], dict):
   |                                                                                         ^^^^^^^^^^^
59 |                     config = yml["options"]
60 |                     LOG.debug(f"[CONFIG] Extracted 'options' block from YAML: {config}")
   |

E501 Line too long (89 > 88)
  --> bb8_core/addon_config.py:69:89
   |
67 |                     _validate_config_schema(config, schema)
68 |                 LOG.debug(f"[CONFIG] Loaded YAML config from {path}: {config}")
69 |                 LOG.debug(f"[CONFIG] Final keys in loaded config: {list(config.keys())}")
   |                                                                                         ^
70 |                 return config
71 |             except Exception as e:
   |

E501 Line too long (91 > 88)
  --> bb8_core/addon_config.py:75:89
   |
73 |         else:
74 |             if "Volumes" in str(path):
75 |                 LOG.debug(f"[CONFIG] Dev-only path skipped (not applicable in HA): {path}")
   |                                                                                         ^^^
76 |             else:
77 |                 LOG.debug(f"[CONFIG] Path not found: {path}")
   |

E501 Line too long (89 > 88)
  --> bb8_core/addon_config.py:84:89
   |
82 | def _validate_config_schema(cfg: Dict, schema: Dict):
83 |     """
84 |     Validate the configuration dictionary `cfg` against the provided `schema` dictionary.
   |                                                                                         ^
85 |
86 |     Args:
   |

E501 Line too long (90 > 88)
  --> bb8_core/addon_config.py:94:89
   |
92 |     for key, typ in schema.items():
93 |         if key not in cfg:
94 |             LOG.warning(f"[CONFIG] Key '{key}' missing from config, expected type {typ}.")
   |                                                                                         ^^
95 |             continue
96 |         val = cfg[key]
   |

E721 Use `is` and `is not` for type comparisons, or `isinstance()` for isinstance checks
   --> bb8_core/addon_config.py:98:29
    |
 96 |         val = cfg[key]
 97 |         # Only basic type checks
 98 |         if typ == "bool" or typ == bool:
    |                             ^^^^^^^^^^^
 99 |             if not isinstance(val, bool):
100 |                 LOG.warning(f"[CONFIG] Key '{key}' expected bool, got {type(val).__name__}.")
    |

E501 Line too long (93 > 88)
   --> bb8_core/addon_config.py:100:89
    |
 98 |         if typ == "bool" or typ == bool:
 99 |             if not isinstance(val, bool):
100 |                 LOG.warning(f"[CONFIG] Key '{key}' expected bool, got {type(val).__name__}.")
    |                                                                                         ^^^^^
101 |         elif typ == "int" or typ == int or typ == "int?":
102 |             try:
    |

E721 Use `is` and `is not` for type comparisons, or `isinstance()` for isinstance checks
   --> bb8_core/addon_config.py:101:30
    |
 99 |             if not isinstance(val, bool):
100 |                 LOG.warning(f"[CONFIG] Key '{key}' expected bool, got {type(val).__name__}.")
101 |         elif typ == "int" or typ == int or typ == "int?":
    |                              ^^^^^^^^^^
102 |             try:
103 |                 int(val)
    |

E501 Line too long (106 > 88)
   --> bb8_core/addon_config.py:105:89
    |
103 |                 int(val)
104 |             except Exception:
105 |                 LOG.warning(f"[CONFIG] Key '{key}' expected int, got {type(val).__name__} value '{val}'.")
    |                                                                                         ^^^^^^^^^^^^^^^^^^
106 |         elif typ == "str" or typ == str or typ == "str?":
107 |             if not isinstance(val, str):
    |

E721 Use `is` and `is not` for type comparisons, or `isinstance()` for isinstance checks
   --> bb8_core/addon_config.py:106:30
    |
104 |             except Exception:
105 |                 LOG.warning(f"[CONFIG] Key '{key}' expected int, got {type(val).__name__} value '{val}'.")
106 |         elif typ == "str" or typ == str or typ == "str?":
    |                              ^^^^^^^^^^
107 |             if not isinstance(val, str):
108 |                 LOG.warning(f"[CONFIG] Key '{key}' expected str, got {type(val).__name__}.")
    |

E501 Line too long (92 > 88)
   --> bb8_core/addon_config.py:108:89
    |
106 |         elif typ == "str" or typ == str or typ == "str?":
107 |             if not isinstance(val, str):
108 |                 LOG.warning(f"[CONFIG] Key '{key}' expected str, got {type(val).__name__}.")
    |                                                                                         ^^^^
109 |
110 | # Modular helper for config key lookup with explicit precedence and YAML mapping
    |

E501 Line too long (120 > 88)
   --> bb8_core/addon_config.py:138:89
    |
137 |     # Use default
138 |     LOG.debug(f"[CONFIG] Key '{key}' (yaml_key='{yaml_key}') not found in env/options/yaml, using default '{default}'.")
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
139 |     return default, "default"
    |

E501 Line too long (100 > 88)
   --> bb8_core/addon_config.py:151:89
    |
150 |     def setk(k, default, yaml_key=None, cast=None):
151 |         """Set config key with precedence: env > options > yaml > default. Optionally cast value."""
    |                                                                                         ^^^^^^^^^^^^
152 |         v, s = _pick(k, env, opt, yml, default, yaml_key)
153 |         LOG.debug(f"[CONFIG] Mapping key '{k}' (yaml_key='{yaml_key}') -> value '{v}' (source: {s})")
    |

E501 Line too long (101 > 88)
   --> bb8_core/addon_config.py:153:89
    |
151 |         """Set config key with precedence: env > options > yaml > default. Optionally cast value."""
152 |         v, s = _pick(k, env, opt, yml, default, yaml_key)
153 |         LOG.debug(f"[CONFIG] Mapping key '{k}' (yaml_key='{yaml_key}') -> value '{v}' (source: {s})")
    |                                                                                         ^^^^^^^^^^^^^
154 |         if cast and v not in (None, ""):
155 |             try:
    |

E501 Line too long (94 > 88)
   --> bb8_core/addon_config.py:158:89
    |
156 |                 v = cast(v)
157 |             except Exception as e:
158 |                 LOG.warning(f"[CONFIG] Failed to cast key '{k}' value '{v}' with {cast}: {e}")
    |                                                                                         ^^^^^^
159 |                 # Don't raise, use the original value
160 |         cfg[k], src[k] = v, s
    |

E501 Line too long (93 > 88)
   --> bb8_core/addon_config.py:163:89
    |
162 |     # After all keys are set, check for all None in critical MQTT keys
163 |     critical_keys = ["MQTT_USERNAME", "MQTT_PASSWORD", "MQTT_HOST", "MQTT_PORT", "MQTT_BASE"]
    |                                                                                         ^^^^^
164 |     if all(cfg.get(k) in (None, "") for k in critical_keys):
165 |         LOG.debug(f"[CONFIG] All critical MQTT config values are None or empty! This usually means the config loader failed, the envi…
    |

E501 Line too long (246 > 88)
   --> bb8_core/addon_config.py:165:89
    |
163 | …QTT_BASE"]
164 | …
165 | …s usually means the config loader failed, the environment is not activated, or config.yaml is missing/unreadable. cfg: { {k: cfg.get(k) for k in critical_keys} }")
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
166 | …
167 | …
    |

E501 Line too long (143 > 88)
   --> bb8_core/addon_config.py:168:89
    |
167 | …ig.yaml user-facing keys)
168 | …ml_key="dispatcher_discovery_enabled", cast=lambda x: str(x).lower() in ("1", "true", "yes"))
    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
169 | … yaml_key="cache_path")
170 | …cache_default_ttl_hours", cast=int)
    |

E501 Line too long (108 > 88)
   --> bb8_core/addon_config.py:181:89
    |
179 |     setk("KEEPALIVE", 60, yaml_key="keepalive", cast=int)
180 |     setk("QOS", 1, yaml_key="qos", cast=int)
181 |     setk("RETAIN", True, yaml_key="discovery_retain", cast=lambda x: str(x).lower() in ("1", "true", "yes"))
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^
182 |     setk("ENABLE_BRIDGE_TELEMETRY", False, yaml_key="enable_bridge_telemetry", cast=lambda x: str(x).lower() in ("1", "true", "yes"))
183 |     setk("TELEMETRY_INTERVAL_S", 20, yaml_key="telemetry_interval_s", cast=int)
    |

E501 Line too long (133 > 88)
   --> bb8_core/addon_config.py:182:89
    |
180 |     setk("QOS", 1, yaml_key="qos", cast=int)
181 |     setk("RETAIN", True, yaml_key="discovery_retain", cast=lambda x: str(x).lower() in ("1", "true", "yes"))
182 |     setk("ENABLE_BRIDGE_TELEMETRY", False, yaml_key="enable_bridge_telemetry", cast=lambda x: str(x).lower() in ("1", "true", "yes"))
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
183 |     setk("TELEMETRY_INTERVAL_S", 20, yaml_key="telemetry_interval_s", cast=int)
184 |     setk("ADDON_VERSION", "unknown", yaml_key="version")
    |

E501 Line too long (119 > 88)
   --> bb8_core/addon_config.py:185:89
    |
183 |     setk("TELEMETRY_INTERVAL_S", 20, yaml_key="telemetry_interval_s", cast=int)
184 |     setk("ADDON_VERSION", "unknown", yaml_key="version")
185 |     setk("DISCOVERY_RETAIN", False, yaml_key="discovery_retain", cast=lambda x: str(x).lower() in ("1", "true", "yes"))
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
186 |     setk("LOG_PATH", "", yaml_key="log_path")
187 |     setk("SCAN_SECONDS", 5, yaml_key="scan_seconds", cast=int)
    |

E501 Line too long (114 > 88)
   --> bb8_core/addon_config.py:188:89
    |
186 |     setk("LOG_PATH", "", yaml_key="log_path")
187 |     setk("SCAN_SECONDS", 5, yaml_key="scan_seconds", cast=int)
188 |     setk("RESCAN_ON_FAIL", True, yaml_key="rescan_on_fail", cast=lambda x: str(x).lower() in ("1", "true", "yes"))
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
189 |     setk("CACHE_TTL_HOURS", 24, yaml_key="cache_ttl_hours", cast=int)
190 |     setk("MQTT_TLS", False, yaml_key="mqtt_tls", cast=lambda x: str(x).lower() in ("1", "true", "yes"))
    |

E501 Line too long (103 > 88)
   --> bb8_core/addon_config.py:190:89
    |
188 |     setk("RESCAN_ON_FAIL", True, yaml_key="rescan_on_fail", cast=lambda x: str(x).lower() in ("1", "true", "yes"))
189 |     setk("CACHE_TTL_HOURS", 24, yaml_key="cache_ttl_hours", cast=int)
190 |     setk("MQTT_TLS", False, yaml_key="mqtt_tls", cast=lambda x: str(x).lower() in ("1", "true", "yes"))
    |                                                                                         ^^^^^^^^^^^^^^^
191 |     setk("BLE_ADAPTER", "hci0", yaml_key="ble_adapter")
192 |     setk("HA_DISCOVERY_TOPIC", "homeassistant", yaml_key="ha_discovery_topic")
    |

E501 Line too long (94 > 88)
   --> bb8_core/addon_config.py:212:89
    |
210 |         f"  MQTT_PORT={cfg['MQTT_PORT']} ⟂ {src['MQTT_PORT']}",
211 |         f"  MQTT_USER='{cfg['MQTT_USERNAME']}' ⟂ {src['MQTT_USERNAME']}",
212 |         f"  MQTT_PASSWORD={'***' if cfg['MQTT_PASSWORD'] else None} ⟂ {src['MQTT_PASSWORD']}",
    |                                                                                         ^^^^^^
213 |         f"  MQTT_BASE='{cfg['MQTT_BASE']}' ⟂ {src['MQTT_BASE']}",
214 |         f"  ENABLE_BRIDGE_TELEMETRY={cfg['ENABLE_BRIDGE_TELEMETRY']} ⟂ {src['ENABLE_BRIDGE_TELEMETRY']}",
    |

E501 Line too long (105 > 88)
   --> bb8_core/addon_config.py:214:89
    |
212 |         f"  MQTT_PASSWORD={'***' if cfg['MQTT_PASSWORD'] else None} ⟂ {src['MQTT_PASSWORD']}",
213 |         f"  MQTT_BASE='{cfg['MQTT_BASE']}' ⟂ {src['MQTT_BASE']}",
214 |         f"  ENABLE_BRIDGE_TELEMETRY={cfg['ENABLE_BRIDGE_TELEMETRY']} ⟂ {src['ENABLE_BRIDGE_TELEMETRY']}",
    |                                                                                         ^^^^^^^^^^^^^^^^^
215 |         f"  TELEMETRY_INTERVAL_S={cfg['TELEMETRY_INTERVAL_S']} ⟂ {src['TELEMETRY_INTERVAL_S']}",
216 |         f"  Add-on version: {cfg['ADDON_VERSION']} ⟂ {src['ADDON_VERSION']}",
    |

E501 Line too long (96 > 88)
   --> bb8_core/addon_config.py:215:89
    |
213 |         f"  MQTT_BASE='{cfg['MQTT_BASE']}' ⟂ {src['MQTT_BASE']}",
214 |         f"  ENABLE_BRIDGE_TELEMETRY={cfg['ENABLE_BRIDGE_TELEMETRY']} ⟂ {src['ENABLE_BRIDGE_TELEMETRY']}",
215 |         f"  TELEMETRY_INTERVAL_S={cfg['TELEMETRY_INTERVAL_S']} ⟂ {src['TELEMETRY_INTERVAL_S']}",
    |                                                                                         ^^^^^^^^
216 |         f"  Add-on version: {cfg['ADDON_VERSION']} ⟂ {src['ADDON_VERSION']}",
217 |     ]
    |

E501 Line too long (108 > 88)
 --> bb8_core/auto_detect.py:5:89
  |
3 | auto_detect.py
4 |
5 | Scans for BB-8 devices, caches MAC addresses, and provides auto-detection logic for robust device discovery.
  |                                                                                         ^^^^^^^^^^^^^^^^^^^^
6 | """
7 | from __future__ import annotations
  |

I001 [*] Import block is un-sorted or un-formatted
  --> bb8_core/auto_detect.py:7:1
   |
 5 |   Scans for BB-8 devices, caches MAC addresses, and provides auto-detection logic for robust device discovery.
 6 |   """
 7 | / from __future__ import annotations
 8 | |
 9 | | # stdlib first
10 | | import json
11 | | import os
12 | | import time
13 | | from typing import Optional, Iterable, Any, List, Tuple
14 | | import contextlib
15 | | import re
16 | |
17 | | # internal imports second
18 | | from .logging_setup import logger
19 | | from .ble_gateway import BleGateway
20 | |
21 | | # module constants at top-level so Pylance can resolve symbols in all scopes
22 | | from .addon_config import load_config
   | |_____________________________________^
23 |   CFG, SRC = load_config()
24 |   CACHE_PATH: str = CFG.get("CACHE_PATH", "/data/bb8_mac_cache.json")
   |
help: Organize imports

I001 [*] Import block is un-sorted or un-formatted
  --> bb8_core/auto_detect.py:39:5
   |
37 | # Lazy import for testability
38 | with contextlib.suppress(ImportError):
39 |     from bleak import BleakScanner, BleakClient  # type: ignore
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
40 |
41 | class Candidate:
   |
help: Organize imports

E501 Line too long (90 > 88)
  --> bb8_core/auto_detect.py:65:89
   |
63 |         if not _valid_mac(data.get("mac", "")):
64 |             return None
65 |         return Candidate(mac=data["mac"], name=data.get("advertised_name", ""), rssi=None)
   |                                                                                         ^^
66 |     except Exception:
67 |         return None
   |

E501 Line too long (101 > 88)
   --> bb8_core/auto_detect.py:192:89
    |
190 | # Minimal Options class for async connect_bb8
191 | class Options:
192 |     def __init__(self, scan_seconds, cache_ttl_hours, rescan_on_fail, adapter=None, cache_path=None):
    |                                                                                         ^^^^^^^^^^^^^
193 |         self.scan_seconds = scan_seconds
194 |         self.cache_ttl_hours = cache_ttl_hours
    |

E501 Line too long (92 > 88)
  --> bb8_core/bb8_presence_scanner.py:9:89
   |
 7 | def publish_extended_discovery(client, base, device_id, device_block):
 8 |     """
 9 |     Publish extended Home Assistant discovery configs for LED, sleep, drive, heading, speed.
   |                                                                                         ^^^^
10 |     Topics and payloads match those in discovery_publish.py for compatibility.
11 |     """
   |

E501 Line too long (111 > 88)
  --> bb8_core/bb8_presence_scanner.py:45:89
   |
43 |         "device": device_block,
44 |     }
45 |     client.publish(f"homeassistant/button/bb8_{device_id}_sleep/config", json.dumps(sleep), qos=1, retain=True)
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^
46 |
47 |     # Drive button (no state_topic in discovery)
   |

E501 Line too long (111 > 88)
  --> bb8_core/bb8_presence_scanner.py:55:89
   |
53 |         "device": device_block,
54 |     }
55 |     client.publish(f"homeassistant/button/bb8_{device_id}_drive/config", json.dumps(drive), qos=1, retain=True)
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^
56 |
57 |     # Heading number
   |

E501 Line too long (115 > 88)
  --> bb8_core/bb8_presence_scanner.py:67:89
   |
65 |         "device": device_block,
66 |     }
67 |     client.publish(f"homeassistant/number/bb8_{device_id}_heading/config", json.dumps(heading), qos=1, retain=True)
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
68 |
69 |     # Speed number
   |

E501 Line too long (111 > 88)
  --> bb8_core/bb8_presence_scanner.py:79:89
   |
77 |         "device": device_block,
78 |     }
79 |     client.publish(f"homeassistant/number/bb8_{device_id}_speed/config", json.dumps(speed), qos=1, retain=True)
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^
80 |
81 |     logger.info("Published extended HA discovery for device_id=%s", device_id)
   |

E501 Line too long (96 > 88)
  --> bb8_core/bb8_presence_scanner.py:85:89
   |
83 | def make_device_id(mac: str) -> str:
84 |     """
85 |     Normalize MAC to lowercase hex without colons (e.g., 'AA:BB:CC:DD:EE:FF' -> 'aabbccddeeff').
   |                                                                                         ^^^^^^^^
86 |     """
87 |     return (mac or '').replace(':', '').lower()
   |

E402 Module level import not at top of file
  --> bb8_core/bb8_presence_scanner.py:94:1
   |
94 | import argparse
   | ^^^^^^^^^^^^^^^
95 | import asyncio
96 | import json
   |

I001 [*] Import block is un-sorted or un-formatted
   --> bb8_core/bb8_presence_scanner.py:94:1
    |
 94 | / import argparse
 95 | | import asyncio
 96 | | import json
 97 | | import logging
 98 | | import os
 99 | | import time
100 | | import threading
101 | | from pathlib import Path
102 | |
103 | | import yaml
104 | | from bleak import BleakScanner
105 | | import paho.mqtt.client as mqtt
106 | | from paho.mqtt.enums import CallbackAPIVersion
107 | | from .addon_config import load_config, log_config
    | |_________________________________________________^
108 |   logger = logging.getLogger("bb8_presence_scanner")
    |
help: Organize imports

E402 Module level import not at top of file
  --> bb8_core/bb8_presence_scanner.py:95:1
   |
94 | import argparse
95 | import asyncio
   | ^^^^^^^^^^^^^^
96 | import json
97 | import logging
   |

E402 Module level import not at top of file
  --> bb8_core/bb8_presence_scanner.py:96:1
   |
94 | import argparse
95 | import asyncio
96 | import json
   | ^^^^^^^^^^^
97 | import logging
98 | import os
   |

E402 Module level import not at top of file
  --> bb8_core/bb8_presence_scanner.py:97:1
   |
95 | import asyncio
96 | import json
97 | import logging
   | ^^^^^^^^^^^^^^
98 | import os
99 | import time
   |

E402 Module level import not at top of file
   --> bb8_core/bb8_presence_scanner.py:98:1
    |
 96 | import json
 97 | import logging
 98 | import os
    | ^^^^^^^^^
 99 | import time
100 | import threading
    |

E402 Module level import not at top of file
   --> bb8_core/bb8_presence_scanner.py:99:1
    |
 97 | import logging
 98 | import os
 99 | import time
    | ^^^^^^^^^^^
100 | import threading
101 | from pathlib import Path
    |

E402 Module level import not at top of file
   --> bb8_core/bb8_presence_scanner.py:100:1
    |
 98 | import os
 99 | import time
100 | import threading
    | ^^^^^^^^^^^^^^^^
101 | from pathlib import Path
    |

E402 Module level import not at top of file
   --> bb8_core/bb8_presence_scanner.py:101:1
    |
 99 | import time
100 | import threading
101 | from pathlib import Path
    | ^^^^^^^^^^^^^^^^^^^^^^^^
102 |
103 | import yaml
    |

F401 [*] `pathlib.Path` imported but unused
   --> bb8_core/bb8_presence_scanner.py:101:21
    |
 99 | import time
100 | import threading
101 | from pathlib import Path
    |                     ^^^^
102 |
103 | import yaml
    |
help: Remove unused import: `pathlib.Path`

E402 Module level import not at top of file
   --> bb8_core/bb8_presence_scanner.py:103:1
    |
101 | from pathlib import Path
102 |
103 | import yaml
    | ^^^^^^^^^^^
104 | from bleak import BleakScanner
105 | import paho.mqtt.client as mqtt
    |

F401 [*] `yaml` imported but unused
   --> bb8_core/bb8_presence_scanner.py:103:8
    |
101 | from pathlib import Path
102 |
103 | import yaml
    |        ^^^^
104 | from bleak import BleakScanner
105 | import paho.mqtt.client as mqtt
    |
help: Remove unused import: `yaml`

E402 Module level import not at top of file
   --> bb8_core/bb8_presence_scanner.py:104:1
    |
103 | import yaml
104 | from bleak import BleakScanner
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
105 | import paho.mqtt.client as mqtt
106 | from paho.mqtt.enums import CallbackAPIVersion
    |

E402 Module level import not at top of file
   --> bb8_core/bb8_presence_scanner.py:105:1
    |
103 | import yaml
104 | from bleak import BleakScanner
105 | import paho.mqtt.client as mqtt
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
106 | from paho.mqtt.enums import CallbackAPIVersion
107 | from .addon_config import load_config, log_config
    |

E402 Module level import not at top of file
   --> bb8_core/bb8_presence_scanner.py:106:1
    |
104 | from bleak import BleakScanner
105 | import paho.mqtt.client as mqtt
106 | from paho.mqtt.enums import CallbackAPIVersion
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
107 | from .addon_config import load_config, log_config
108 | logger = logging.getLogger("bb8_presence_scanner")
    |

E402 Module level import not at top of file
   --> bb8_core/bb8_presence_scanner.py:107:1
    |
105 | import paho.mqtt.client as mqtt
106 | from paho.mqtt.enums import CallbackAPIVersion
107 | from .addon_config import load_config, log_config
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
108 | logger = logging.getLogger("bb8_presence_scanner")
    |

E501 Line too long (98 > 88)
   --> bb8_core/bb8_presence_scanner.py:117:89
    |
115 | BB8_NAME  = CFG.get("BB8_NAME", "BB-8")
116 | DISCOVERY_RETAIN    = CFG.get("DISCOVERY_RETAIN", False)
117 | EXTENDED_DISCOVERY  = os.environ.get("EXTENDED_DISCOVERY", "1") not in ("0", "false", "no", "off")
    |                                                                                         ^^^^^^^^^^
118 | EXTENDED_COMMANDS   = os.environ.get("EXTENDED_COMMANDS", "1") not in ("0", "false", "no", "off")
119 | REQUIRE_DEVICE_ECHO = os.environ.get("REQUIRE_DEVICE_ECHO", "1") not in ("0", "false", "no", "off")
    |

E501 Line too long (97 > 88)
   --> bb8_core/bb8_presence_scanner.py:118:89
    |
116 | DISCOVERY_RETAIN    = CFG.get("DISCOVERY_RETAIN", False)
117 | EXTENDED_DISCOVERY  = os.environ.get("EXTENDED_DISCOVERY", "1") not in ("0", "false", "no", "off")
118 | EXTENDED_COMMANDS   = os.environ.get("EXTENDED_COMMANDS", "1") not in ("0", "false", "no", "off")
    |                                                                                         ^^^^^^^^^
119 | REQUIRE_DEVICE_ECHO = os.environ.get("REQUIRE_DEVICE_ECHO", "1") not in ("0", "false", "no", "off")
120 | HA_DISCOVERY_TOPIC = CFG.get("HA_DISCOVERY_TOPIC", "homeassistant")
    |

E501 Line too long (99 > 88)
   --> bb8_core/bb8_presence_scanner.py:119:89
    |
117 | EXTENDED_DISCOVERY  = os.environ.get("EXTENDED_DISCOVERY", "1") not in ("0", "false", "no", "off")
118 | EXTENDED_COMMANDS   = os.environ.get("EXTENDED_COMMANDS", "1") not in ("0", "false", "no", "off")
119 | REQUIRE_DEVICE_ECHO = os.environ.get("REQUIRE_DEVICE_ECHO", "1") not in ("0", "false", "no", "off")
    |                                                                                         ^^^^^^^^^^^
120 | HA_DISCOVERY_TOPIC = CFG.get("HA_DISCOVERY_TOPIC", "homeassistant")
121 | log_config(CFG, SRC, logger)
    |

E501 Line too long (92 > 88)
   --> bb8_core/bb8_presence_scanner.py:127:89
    |
125 | # -----------------------------------------------------------------------------
126 |
127 | parser = argparse.ArgumentParser(description="BB-8 BLE presence scanner and MQTT publisher")
    |                                                                                         ^^^^
128 | parser.add_argument("--bb8_name", default=CFG.get("BB8_NAME", "BB-8"), help="BB-8 BLE name")
129 | parser.add_argument("--scan_interval", type=int, default=int(CFG.get("BB8_SCAN_INTERVAL", 10)), help="Scan interval in seconds")
    |

E501 Line too long (92 > 88)
   --> bb8_core/bb8_presence_scanner.py:128:89
    |
127 | parser = argparse.ArgumentParser(description="BB-8 BLE presence scanner and MQTT publisher")
128 | parser.add_argument("--bb8_name", default=CFG.get("BB8_NAME", "BB-8"), help="BB-8 BLE name")
    |                                                                                         ^^^^
129 | parser.add_argument("--scan_interval", type=int, default=int(CFG.get("BB8_SCAN_INTERVAL", 10)), help="Scan interval in seconds")
130 | parser.add_argument("--mqtt_host", default=CFG.get("MQTT_HOST", "localhost"), help="MQTT broker host")
    |

E501 Line too long (128 > 88)
   --> bb8_core/bb8_presence_scanner.py:129:89
    |
127 | parser = argparse.ArgumentParser(description="BB-8 BLE presence scanner and MQTT publisher")
128 | parser.add_argument("--bb8_name", default=CFG.get("BB8_NAME", "BB-8"), help="BB-8 BLE name")
129 | parser.add_argument("--scan_interval", type=int, default=int(CFG.get("BB8_SCAN_INTERVAL", 10)), help="Scan interval in seconds")
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
130 | parser.add_argument("--mqtt_host", default=CFG.get("MQTT_HOST", "localhost"), help="MQTT broker host")
131 | parser.add_argument("--mqtt_port", type=int, default=int(CFG.get("MQTT_PORT", 1883)), help="MQTT broker port")
    |

E501 Line too long (102 > 88)
   --> bb8_core/bb8_presence_scanner.py:130:89
    |
128 | parser.add_argument("--bb8_name", default=CFG.get("BB8_NAME", "BB-8"), help="BB-8 BLE name")
129 | parser.add_argument("--scan_interval", type=int, default=int(CFG.get("BB8_SCAN_INTERVAL", 10)), help="Scan interval in seconds")
130 | parser.add_argument("--mqtt_host", default=CFG.get("MQTT_HOST", "localhost"), help="MQTT broker host")
    |                                                                                         ^^^^^^^^^^^^^^
131 | parser.add_argument("--mqtt_port", type=int, default=int(CFG.get("MQTT_PORT", 1883)), help="MQTT broker port")
132 | parser.add_argument("--mqtt_user", default=CFG.get("MQTT_USERNAME", None), help="MQTT username")
    |

E501 Line too long (110 > 88)
   --> bb8_core/bb8_presence_scanner.py:131:89
    |
129 | parser.add_argument("--scan_interval", type=int, default=int(CFG.get("BB8_SCAN_INTERVAL", 10)), help="Scan interval in seconds")
130 | parser.add_argument("--mqtt_host", default=CFG.get("MQTT_HOST", "localhost"), help="MQTT broker host")
131 | parser.add_argument("--mqtt_port", type=int, default=int(CFG.get("MQTT_PORT", 1883)), help="MQTT broker port")
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^
132 | parser.add_argument("--mqtt_user", default=CFG.get("MQTT_USERNAME", None), help="MQTT username")
133 | parser.add_argument("--mqtt_password", default=CFG.get("MQTT_PASSWORD", None), help="MQTT password")
    |

E501 Line too long (96 > 88)
   --> bb8_core/bb8_presence_scanner.py:132:89
    |
130 | parser.add_argument("--mqtt_host", default=CFG.get("MQTT_HOST", "localhost"), help="MQTT broker host")
131 | parser.add_argument("--mqtt_port", type=int, default=int(CFG.get("MQTT_PORT", 1883)), help="MQTT broker port")
132 | parser.add_argument("--mqtt_user", default=CFG.get("MQTT_USERNAME", None), help="MQTT username")
    |                                                                                         ^^^^^^^^
133 | parser.add_argument("--mqtt_password", default=CFG.get("MQTT_PASSWORD", None), help="MQTT password")
134 | parser.add_argument("--print", action="store_true", help="Print discovery payloads and exit")
    |

E501 Line too long (100 > 88)
   --> bb8_core/bb8_presence_scanner.py:133:89
    |
131 | parser.add_argument("--mqtt_port", type=int, default=int(CFG.get("MQTT_PORT", 1883)), help="MQTT broker port")
132 | parser.add_argument("--mqtt_user", default=CFG.get("MQTT_USERNAME", None), help="MQTT username")
133 | parser.add_argument("--mqtt_password", default=CFG.get("MQTT_PASSWORD", None), help="MQTT password")
    |                                                                                         ^^^^^^^^^^^^
134 | parser.add_argument("--print", action="store_true", help="Print discovery payloads and exit")
135 | parser.add_argument("--once", action="store_true", help="Run one scan cycle and exit")
    |

E501 Line too long (93 > 88)
   --> bb8_core/bb8_presence_scanner.py:134:89
    |
132 | parser.add_argument("--mqtt_user", default=CFG.get("MQTT_USERNAME", None), help="MQTT username")
133 | parser.add_argument("--mqtt_password", default=CFG.get("MQTT_PASSWORD", None), help="MQTT password")
134 | parser.add_argument("--print", action="store_true", help="Print discovery payloads and exit")
    |                                                                                         ^^^^^
135 | parser.add_argument("--once", action="store_true", help="Run one scan cycle and exit")
136 | parser.add_argument("--json", action="store_true", help="Emit JSON on one-shot runs")
    |

E501 Line too long (91 > 88)
   --> bb8_core/bb8_presence_scanner.py:137:89
    |
135 | parser.add_argument("--once", action="store_true", help="Run one scan cycle and exit")
136 | parser.add_argument("--json", action="store_true", help="Emit JSON on one-shot runs")
137 | parser.add_argument("--verbose", "-v", action="store_true", help="Verbose not-found ticks")
    |                                                                                         ^^^
138 | parser.add_argument("--quiet", "-q", action="store_true", help="No periodic tick output")
    |

E501 Line too long (89 > 88)
   --> bb8_core/bb8_presence_scanner.py:138:89
    |
136 | parser.add_argument("--json", action="store_true", help="Emit JSON on one-shot runs")
137 | parser.add_argument("--verbose", "-v", action="store_true", help="Verbose not-found ticks")
138 | parser.add_argument("--quiet", "-q", action="store_true", help="No periodic tick output")
    |                                                                                         ^
139 |
140 | # CLI toggles for extended entities are now ignored; use EXTENDED_DISCOVERY env var only
    |

E501 Line too long (95 > 88)
   --> bb8_core/bb8_presence_scanner.py:146:89
    |
145 | # EXTENDED_ENABLED: single toggle, default off, controlled by EXTENDED_DISCOVERY env var
146 | EXTENDED_ENABLED = os.environ.get("EXTENDED_DISCOVERY", "0") not in ("0", "false", "no", "off")
    |                                                                                         ^^^^^^^
147 |
148 | BB8_NAME = args.bb8_name
    |

E501 Line too long (117 > 88)
   --> bb8_core/bb8_presence_scanner.py:239:89
    |
237 | CMD_POWER_SET   = f"{MQTT_BASE}/cmd/power_set"      # payload: "ON"|"OFF"
238 | CMD_STOP_PRESS  = f"{MQTT_BASE}/cmd/stop_press"     # payload: anything
239 | CMD_LED_SET     = f"{MQTT_BASE}/cmd/led_set"        # payload: {{"r":..,"g":..,"b":..}} | {{"hex":"#RRGGBB"}} | "OFF"
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
240 | CMD_HEADING_SET = f"{MQTT_BASE}/cmd/heading_set"    # payload: number 0..359
241 | CMD_SPEED_SET   = f"{MQTT_BASE}/cmd/speed_set"      # payload: number 0..255
    |

E702 Multiple statements on one line (semicolon)
   --> bb8_core/bb8_presence_scanner.py:334:45
    |
332 |                 c = obj["color"]
333 |                 if all(k in c for k in ("r","g","b")):
334 |                     r = _clamp(c["r"],0,255); g = _clamp(c["g"],0,255); b = _clamp(c["b"],0,255)
    |                                             ^
335 |                     return ("RGB", (r,g,b))
    |

E702 Multiple statements on one line (semicolon)
   --> bb8_core/bb8_presence_scanner.py:334:71
    |
332 |                 c = obj["color"]
333 |                 if all(k in c for k in ("r","g","b")):
334 |                     r = _clamp(c["r"],0,255); g = _clamp(c["g"],0,255); b = _clamp(c["b"],0,255)
    |                                                                       ^
335 |                     return ("RGB", (r,g,b))
    |

E501 Line too long (96 > 88)
   --> bb8_core/bb8_presence_scanner.py:334:89
    |
332 |                 c = obj["color"]
333 |                 if all(k in c for k in ("r","g","b")):
334 |                     r = _clamp(c["r"],0,255); g = _clamp(c["g"],0,255); b = _clamp(c["b"],0,255)
    |                                                                                         ^^^^^^^^
335 |                     return ("RGB", (r,g,b))
    |

E702 Multiple statements on one line (semicolon)
   --> bb8_core/bb8_presence_scanner.py:339:43
    |
337 |             # Legacy direct {r,g,b}
338 |             if all(k in obj for k in ("r","g","b")):
339 |                 r = _clamp(obj["r"],0,255); g = _clamp(obj["g"],0,255); b = _clamp(obj["b"],0,255)
    |                                           ^
340 |                 return ("RGB", (r,g,b))
    |

E702 Multiple statements on one line (semicolon)
   --> bb8_core/bb8_presence_scanner.py:339:71
    |
337 |             # Legacy direct {r,g,b}
338 |             if all(k in obj for k in ("r","g","b")):
339 |                 r = _clamp(obj["r"],0,255); g = _clamp(obj["g"],0,255); b = _clamp(obj["b"],0,255)
    |                                                                       ^
340 |                 return ("RGB", (r,g,b))
    |

E501 Line too long (98 > 88)
   --> bb8_core/bb8_presence_scanner.py:339:89
    |
337 |             # Legacy direct {r,g,b}
338 |             if all(k in obj for k in ("r","g","b")):
339 |                 r = _clamp(obj["r"],0,255); g = _clamp(obj["g"],0,255); b = _clamp(obj["b"],0,255)
    |                                                                                         ^^^^^^^^^^
340 |                 return ("RGB", (r,g,b))
    |

E702 Multiple statements on one line (semicolon)
   --> bb8_core/bb8_presence_scanner.py:346:40
    |
344 |                 hx = obj["hex"].lstrip("#")
345 |                 if len(hx) == 6:
346 |                     r = int(hx[0:2],16); g = int(hx[2:4],16); b = int(hx[4:6],16)
    |                                        ^
347 |                     return ("RGB", (r,g,b))
348 |     except Exception:
    |

E702 Multiple statements on one line (semicolon)
   --> bb8_core/bb8_presence_scanner.py:346:61
    |
344 |                 hx = obj["hex"].lstrip("#")
345 |                 if len(hx) == 6:
346 |                     r = int(hx[0:2],16); g = int(hx[2:4],16); b = int(hx[4:6],16)
    |                                                             ^
347 |                     return ("RGB", (r,g,b))
348 |     except Exception:
    |

E701 Multiple statements on one line (colon)
   --> bb8_core/bb8_presence_scanner.py:376:8
    |
375 | def _cb_stop_press(client, userdata, msg):
376 |     try: FACADE.stop()
    |        ^
377 |     except Exception as e: logger.warning("facade.stop() failed: %s", e)
378 |     client.publish(FLAT_STOP_STATE, "pressed", qos=1, retain=False)
    |

E701 Multiple statements on one line (colon)
   --> bb8_core/bb8_presence_scanner.py:377:26
    |
375 | def _cb_stop_press(client, userdata, msg):
376 |     try: FACADE.stop()
377 |     except Exception as e: logger.warning("facade.stop() failed: %s", e)
    |                          ^
378 |     client.publish(FLAT_STOP_STATE, "pressed", qos=1, retain=False)
379 |     client.publish(LEGACY_STOP_STATE, "pressed", qos=1, retain=False)
    |

E501 Line too long (90 > 88)
   --> bb8_core/bb8_presence_scanner.py:390:89
    |
388 |     try:
389 |         d = json.loads(raw) if raw else {}
390 |         # Accept HA-native: {"state":"ON","color":{"r":..,"g":..,"b":..},"brightness":...}
    |                                                                                         ^^
391 |         if isinstance(d, dict) and d.get("state", "").upper() == "ON":
392 |             col = d.get("color") or {}
    |

E501 Line too long (117 > 88)
   --> bb8_core/bb8_presence_scanner.py:395:89
    |
393 |             r, g, b = int(col.get("r", 0)), int(col.get("g", 0)), int(col.get("b", 0))
394 |             brightness = int(d.get("brightness", 255))
395 |             state = {"state": "ON", "color": {"r": r, "g": g, "b": b}, "color_mode": "rgb", "brightness": brightness}
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
396 |             try: FACADE.set_led_rgb(r, g, b)
397 |             except Exception as e: logger.warning("facade.set_led_rgb() failed: %s", e)
    |

E701 Multiple statements on one line (colon)
   --> bb8_core/bb8_presence_scanner.py:396:16
    |
394 |             brightness = int(d.get("brightness", 255))
395 |             state = {"state": "ON", "color": {"r": r, "g": g, "b": b}, "color_mode": "rgb", "brightness": brightness}
396 |             try: FACADE.set_led_rgb(r, g, b)
    |                ^
397 |             except Exception as e: logger.warning("facade.set_led_rgb() failed: %s", e)
398 |         # Accept legacy shapes too:
    |

E701 Multiple statements on one line (colon)
   --> bb8_core/bb8_presence_scanner.py:397:34
    |
395 |             state = {"state": "ON", "color": {"r": r, "g": g, "b": b}, "color_mode": "rgb", "brightness": brightness}
396 |             try: FACADE.set_led_rgb(r, g, b)
397 |             except Exception as e: logger.warning("facade.set_led_rgb() failed: %s", e)
    |                                  ^
398 |         # Accept legacy shapes too:
399 |         elif "hex" in d:
    |

E501 Line too long (117 > 88)
   --> bb8_core/bb8_presence_scanner.py:403:89
    |
401 |             r, g, b = int(hx[0:2], 16), int(hx[2:4], 16), int(hx[4:6], 16)
402 |             brightness = int(d.get("brightness", 255))
403 |             state = {"state": "ON", "color": {"r": r, "g": g, "b": b}, "color_mode": "rgb", "brightness": brightness}
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
404 |             try: FACADE.set_led_rgb(r, g, b)
405 |             except Exception as e: logger.warning("facade.set_led_rgb() failed: %s", e)
    |

E701 Multiple statements on one line (colon)
   --> bb8_core/bb8_presence_scanner.py:404:16
    |
402 |             brightness = int(d.get("brightness", 255))
403 |             state = {"state": "ON", "color": {"r": r, "g": g, "b": b}, "color_mode": "rgb", "brightness": brightness}
404 |             try: FACADE.set_led_rgb(r, g, b)
    |                ^
405 |             except Exception as e: logger.warning("facade.set_led_rgb() failed: %s", e)
406 |         elif {"r", "g", "b"}.issubset(d.keys()):
    |

E701 Multiple statements on one line (colon)
   --> bb8_core/bb8_presence_scanner.py:405:34
    |
403 |             state = {"state": "ON", "color": {"r": r, "g": g, "b": b}, "color_mode": "rgb", "brightness": brightness}
404 |             try: FACADE.set_led_rgb(r, g, b)
405 |             except Exception as e: logger.warning("facade.set_led_rgb() failed: %s", e)
    |                                  ^
406 |         elif {"r", "g", "b"}.issubset(d.keys()):
407 |             r, g, b = int(d["r"]), int(d["g"]), int(d["b"])
    |

E501 Line too long (117 > 88)
   --> bb8_core/bb8_presence_scanner.py:409:89
    |
407 |             r, g, b = int(d["r"]), int(d["g"]), int(d["b"])
408 |             brightness = int(d.get("brightness", 255))
409 |             state = {"state": "ON", "color": {"r": r, "g": g, "b": b}, "color_mode": "rgb", "brightness": brightness}
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
410 |             try: FACADE.set_led_rgb(r, g, b)
411 |             except Exception as e: logger.warning("facade.set_led_rgb() failed: %s", e)
    |

E701 Multiple statements on one line (colon)
   --> bb8_core/bb8_presence_scanner.py:410:16
    |
408 |             brightness = int(d.get("brightness", 255))
409 |             state = {"state": "ON", "color": {"r": r, "g": g, "b": b}, "color_mode": "rgb", "brightness": brightness}
410 |             try: FACADE.set_led_rgb(r, g, b)
    |                ^
411 |             except Exception as e: logger.warning("facade.set_led_rgb() failed: %s", e)
412 |         elif raw.upper() == "OFF":
    |

E701 Multiple statements on one line (colon)
   --> bb8_core/bb8_presence_scanner.py:411:34
    |
409 |             state = {"state": "ON", "color": {"r": r, "g": g, "b": b}, "color_mode": "rgb", "brightness": brightness}
410 |             try: FACADE.set_led_rgb(r, g, b)
411 |             except Exception as e: logger.warning("facade.set_led_rgb() failed: %s", e)
    |                                  ^
412 |         elif raw.upper() == "OFF":
413 |             try: FACADE.set_led_off()
    |

E701 Multiple statements on one line (colon)
   --> bb8_core/bb8_presence_scanner.py:413:16
    |
411 |             except Exception as e: logger.warning("facade.set_led_rgb() failed: %s", e)
412 |         elif raw.upper() == "OFF":
413 |             try: FACADE.set_led_off()
    |                ^
414 |             except Exception as e: logger.warning("facade.set_led_off() failed: %s", e)
415 |             state = {"state": "OFF"}
    |

E701 Multiple statements on one line (colon)
   --> bb8_core/bb8_presence_scanner.py:414:34
    |
412 |         elif raw.upper() == "OFF":
413 |             try: FACADE.set_led_off()
414 |             except Exception as e: logger.warning("facade.set_led_off() failed: %s", e)
    |                                  ^
415 |             state = {"state": "OFF"}
416 |         else:
    |

E701 Multiple statements on one line (colon)
   --> bb8_core/bb8_presence_scanner.py:421:12
    |
419 |         if raw.upper() != "OFF":
420 |             return
421 |         try: FACADE.set_led_off()
    |            ^
422 |         except Exception as e: logger.warning("facade.set_led_off() failed: %s", e)
423 |         state = {"state": "OFF"}
    |

E701 Multiple statements on one line (colon)
   --> bb8_core/bb8_presence_scanner.py:422:30
    |
420 |             return
421 |         try: FACADE.set_led_off()
422 |         except Exception as e: logger.warning("facade.set_led_off() failed: %s", e)
    |                              ^
423 |         state = {"state": "OFF"}
424 |     client.publish(FLAT_LED_STATE, json.dumps(state), qos=1, retain=False)
    |

E701 Multiple statements on one line (colon)
   --> bb8_core/bb8_presence_scanner.py:437:8
    |
435 |         logger.warning("heading_set invalid payload: %r", msg.payload)
436 |         return
437 |     try: FACADE.set_heading(deg)
    |        ^
438 |     except Exception as e: logger.warning("facade.set_heading(%s) failed: %s", deg, e)
439 |     client.publish(FLAT_HEADING_STATE, str(deg), qos=1, retain=False)
    |

E701 Multiple statements on one line (colon)
   --> bb8_core/bb8_presence_scanner.py:438:26
    |
436 |         return
437 |     try: FACADE.set_heading(deg)
438 |     except Exception as e: logger.warning("facade.set_heading(%s) failed: %s", deg, e)
    |                          ^
439 |     client.publish(FLAT_HEADING_STATE, str(deg), qos=1, retain=False)
440 |     client.publish(LEGACY_HEADING_STATE, str(deg), qos=1, retain=False)
    |

E701 Multiple statements on one line (colon)
   --> bb8_core/bb8_presence_scanner.py:452:8
    |
450 |         logger.warning("speed_set invalid payload: %r", msg.payload)
451 |         return
452 |     try: FACADE.set_speed(spd)
    |        ^
453 |     except Exception as e: logger.warning("facade.set_speed(%s) failed: %s", spd, e)
454 |     client.publish(FLAT_SPEED_STATE, str(spd), qos=1, retain=False)
    |

E701 Multiple statements on one line (colon)
   --> bb8_core/bb8_presence_scanner.py:453:26
    |
451 |         return
452 |     try: FACADE.set_speed(spd)
453 |     except Exception as e: logger.warning("facade.set_speed(%s) failed: %s", spd, e)
    |                          ^
454 |     client.publish(FLAT_SPEED_STATE, str(spd), qos=1, retain=False)
455 |     client.publish(LEGACY_SPEED_STATE, str(spd), qos=1, retain=False)
    |

E701 Multiple statements on one line (colon)
   --> bb8_core/bb8_presence_scanner.py:458:8
    |
457 | def _cb_drive_press(client, userdata, msg):
458 |     try: FACADE.drive()
    |        ^
459 |     except Exception as e: logger.warning("facade.drive() failed: %s", e)
460 |     client.publish(FLAT_STOP_STATE, "pressed", qos=1, retain=False)
    |

E701 Multiple statements on one line (colon)
   --> bb8_core/bb8_presence_scanner.py:459:26
    |
457 | def _cb_drive_press(client, userdata, msg):
458 |     try: FACADE.drive()
459 |     except Exception as e: logger.warning("facade.drive() failed: %s", e)
    |                          ^
460 |     client.publish(FLAT_STOP_STATE, "pressed", qos=1, retain=False)
461 |     client.publish(LEGACY_STOP_STATE, "pressed", qos=1, retain=False)
    |

E501 Line too long (103 > 88)
   --> bb8_core/bb8_presence_scanner.py:486:89
    |
484 |     if not mac and getattr(device, "address", ""):
485 |         mac = device.address.upper()
486 |     dbus_path = details.get("path") or (f"/org/bluez/hci0/dev_{mac.replace(':','_')}" if mac else None)
    |                                                                                         ^^^^^^^^^^^^^^^
487 |     return mac or None, dbus_path
    |

E501 Line too long (89 > 88)
   --> bb8_core/bb8_presence_scanner.py:489:89
    |
487 |     return mac or None, dbus_path
488 |
489 | def build_device_block(mac: str, dbus_path: str, model: str, name: str = "BB-8") -> dict:
    |                                                                                         ^
490 |     """
491 |     Build a Home Assistant-compliant 'device' block for MQTT Discovery.
    |

E501 Line too long (102 > 88)
   --> bb8_core/bb8_presence_scanner.py:512:89
    |
510 |     }
511 |
512 | def publish_discovery(client: mqtt.Client, mac: str, dbus_path: str, model: str = "", name: str = ""):
    |                                                                                         ^^^^^^^^^^^^^^
513 |     """
514 |     Publish Home Assistant discovery for Presence and RSSI with full device block.
    |

E501 Line too long (105 > 88)
   --> bb8_core/bb8_presence_scanner.py:516:89
    |
514 |     Publish Home Assistant discovery for Presence and RSSI with full device block.
515 |     """
516 |     # TODO: Store and map device_defaults from facade_mapping_table.json to retrievable dynamic variables
    |                                                                                         ^^^^^^^^^^^^^^^^^
517 |     model_hint = model if model else CFG.get("BB8_NAME", "S33 BB84 LE")
518 |     name_hint = name if name else CFG.get("BB8_NAME", "BB-8")
    |

E501 Line too long (124 > 88)
   --> bb8_core/bb8_presence_scanner.py:547:89
    |
545 |         "device": device,
546 |     }
547 |     client.publish(f"{HA_DISCOVERY_TOPIC}/binary_sensor/bb8_presence/config", json.dumps(presence_disc), qos=1, retain=True)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
548 |     client.publish(f"{HA_DISCOVERY_TOPIC}/sensor/bb8_rssi/config", json.dumps(rssi_disc), qos=1, retain=True)
549 |     logger.info("Published HA discovery for MAC=%s", mac)
    |

E501 Line too long (109 > 88)
   --> bb8_core/bb8_presence_scanner.py:548:89
    |
546 |     }
547 |     client.publish(f"{HA_DISCOVERY_TOPIC}/binary_sensor/bb8_presence/config", json.dumps(presence_disc), qos=1, retain=True)
548 |     client.publish(f"{HA_DISCOVERY_TOPIC}/sensor/bb8_rssi/config", json.dumps(rssi_disc), qos=1, retain=True)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^
549 |     logger.info("Published HA discovery for MAC=%s", mac)
    |

E501 Line too long (112 > 88)
   --> bb8_core/bb8_presence_scanner.py:560:89
    |
558 |         return
559 |     if args.json:
560 |         print(json.dumps({"ts": int(time.time()), "found": found, "name": name, "address": addr, "rssi": rssi}))
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^
561 |     else:
562 |         if found:
    |

E501 Line too long (91 > 88)
   --> bb8_core/bb8_presence_scanner.py:573:89
    |
571 | async def scan_and_publish():
572 |     """
573 |     Scan loop: find BB-8, publish presence/RSSI (retained), publish discovery once per MAC.
    |                                                                                         ^^^
574 |     """
575 |     published_discovery_for = None  # last MAC we advertised
    |

E501 Line too long (101 > 88)
   --> bb8_core/bb8_presence_scanner.py:594:89
    |
592 |                     rssi = getattr(d, "rssi", None)
593 |                     if rssi is None:
594 |                         rssi = ((getattr(d, "details", {}) or {}).get("props", {}) or {}).get("RSSI")
    |                                                                                         ^^^^^^^^^^^^^
595 |                     mac, dbus_path = _extract_mac_and_dbus(d)
596 |                     logger.info("Found BB-8: %s [%s] RSSI: %s UUIDs: %s",
    |

E501 Line too long (104 > 88)
   --> bb8_core/bb8_presence_scanner.py:598:89
    |
596 |                     logger.info("Found BB-8: %s [%s] RSSI: %s UUIDs: %s",
597 |                                 d.name, mac, rssi,
598 |                                 ((getattr(d, 'details', {}) or {}).get('props', {}) or {}).get('UUIDs'))
    |                                                                                         ^^^^^^^^^^^^^^^^
599 |                     break
    |

E501 Line too long (93 > 88)
   --> bb8_core/bb8_presence_scanner.py:604:89
    |
602 |             if found and mac and dbus_path and published_discovery_for != mac:
603 |                 # Minimal discovery (presence/RSSI)
604 |                 publish_discovery(mqtt_client, mac, dbus_path, model=model_hint, name="BB-8")
    |                                                                                         ^^^^^
605 |                 # Extended discovery (if enabled)
606 |                 if EXTENDED_ENABLED:
    |

E501 Line too long (100 > 88)
   --> bb8_core/bb8_presence_scanner.py:609:89
    |
607 |                     device_id = make_device_id(mac)
608 |                     base = make_base(device_id)
609 |                     device_block = build_device_block(mac, dbus_path, model=model_hint, name="BB-8")
    |                                                                                         ^^^^^^^^^^^^
610 |                     publish_extended_discovery(mqtt_client, base, device_id, device_block)
611 |                 published_discovery_for = mac
    |

E501 Line too long (90 > 88)
   --> bb8_core/bb8_presence_scanner.py:610:89
    |
608 |                     base = make_base(device_id)
609 |                     device_block = build_device_block(mac, dbus_path, model=model_hint, name="BB-8")
610 |                     publish_extended_discovery(mqtt_client, base, device_id, device_block)
    |                                                                                         ^^
611 |                 published_discovery_for = mac
    |

E501 Line too long (110 > 88)
   --> bb8_core/bb8_presence_scanner.py:622:89
    |
620 |                 })
621 |                 import os
622 |                 enable_telemetry = str(os.environ.get("ENABLE_BRIDGE_TELEMETRY", "0")) in ("1", "true", "yes")
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^
623 |                 if enable_telemetry:
624 |                     mqtt_client.publish(f"{MQTT_BASE}/sensor/presence", "on" if found else "off", qos=1, retain=True)
    |

E501 Line too long (117 > 88)
   --> bb8_core/bb8_presence_scanner.py:624:89
    |
622 |                 enable_telemetry = str(os.environ.get("ENABLE_BRIDGE_TELEMETRY", "0")) in ("1", "true", "yes")
623 |                 if enable_telemetry:
624 |                     mqtt_client.publish(f"{MQTT_BASE}/sensor/presence", "on" if found else "off", qos=1, retain=True)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
625 |                     mqtt_client.publish(f"{MQTT_BASE}/sensor/rssi", "" if rssi is None else str(int(rssi)), qos=1, retain=True)
626 |                 logger.info({
    |

E501 Line too long (127 > 88)
   --> bb8_core/bb8_presence_scanner.py:625:89
    |
623 |                 if enable_telemetry:
624 |                     mqtt_client.publish(f"{MQTT_BASE}/sensor/presence", "on" if found else "off", qos=1, retain=True)
625 |                     mqtt_client.publish(f"{MQTT_BASE}/sensor/rssi", "" if rssi is None else str(int(rssi)), qos=1, retain=True)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
626 |                 logger.info({
627 |                     "event": "telemetry_loop_started",
    |

E501 Line too long (94 > 88)
   --> bb8_core/bb8_presence_scanner.py:647:89
    |
645 |     if args.print:
646 |         # Discovery is emitted lazily after MAC/DBus are known; nothing to print upfront
647 |         print("# discovery will be published after a successful scan when MAC/DBus are known")
    |                                                                                         ^^^^^^
648 |         raise SystemExit(0)
    |

E501 Line too long (109 > 88)
   --> bb8_core/bb8_presence_scanner.py:656:89
    |
654 |             for d in devices:
655 |                 if BB8_NAME.lower() in (d.name or "").lower():
656 |                     res = {"found": True, "name": d.name or BB8_NAME, "address": getattr(d, "address", None),
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^
657 |                            "rssi": getattr(d, "rssi", None)}
658 |                     break
    |

I001 [*] Import block is un-sorted or un-formatted
 --> bb8_core/ble_bridge.py:1:1
  |
1 | / from __future__ import annotations
2 | | from typing import TYPE_CHECKING
3 | | from .addon_config import load_config
  | |_____________________________________^
4 |   CFG, SRC = load_config()
  |
help: Organize imports

E501 Line too long (127 > 88)
  --> bb8_core/ble_bridge.py:9:89
   |
 7 | ble_bridge.py
 8 |
 9 | Orchestrates BLE operations for BB-8, manages device connection, and exposes diagnostics for Home Assistant add-on integration.
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
10 | """
   |

E402 Module level import not at top of file
  --> bb8_core/ble_bridge.py:12:1
   |
10 | """
11 |
12 | from typing import Optional, Any, List, Tuple, TYPE_CHECKING
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 | from .types import (
14 |     BridgeController,
   |

I001 [*] Import block is un-sorted or un-formatted
  --> bb8_core/ble_bridge.py:12:1
   |
10 |   """
11 |
12 | / from typing import Optional, Any, List, Tuple, TYPE_CHECKING
13 | | from .types import (
14 | |     BridgeController,
15 | |     BLELink,
16 | |     MqttClient,
17 | |     BoolCallback,
18 | |     IntCallback,
19 | |     OptIntCallback,
20 | |     RGBCallback,
21 | | )
   | |_^
22 |   if TYPE_CHECKING:
23 |       from .bridge_controller import BridgeController as _BridgeControllerHint
   |
help: Organize imports

F401 [*] `typing.List` imported but unused
  --> bb8_core/ble_bridge.py:12:35
   |
10 | """
11 |
12 | from typing import Optional, Any, List, Tuple, TYPE_CHECKING
   |                                   ^^^^
13 | from .types import (
14 |     BridgeController,
   |
help: Remove unused import

F401 [*] `typing.Tuple` imported but unused
  --> bb8_core/ble_bridge.py:12:41
   |
10 | """
11 |
12 | from typing import Optional, Any, List, Tuple, TYPE_CHECKING
   |                                         ^^^^^
13 | from .types import (
14 |     BridgeController,
   |
help: Remove unused import

F811 [*] Redefinition of unused `TYPE_CHECKING` from line 2
  --> bb8_core/ble_bridge.py:12:48
   |
10 | """
11 |
12 | from typing import Optional, Any, List, Tuple, TYPE_CHECKING
   |                                                ^^^^^^^^^^^^^
13 | from .types import (
14 |     BridgeController,
   |
help: Remove definition: `TYPE_CHECKING`

E402 Module level import not at top of file
  --> bb8_core/ble_bridge.py:13:1
   |
12 |   from typing import Optional, Any, List, Tuple, TYPE_CHECKING
13 | / from .types import (
14 | |     BridgeController,
15 | |     BLELink,
16 | |     MqttClient,
17 | |     BoolCallback,
18 | |     IntCallback,
19 | |     OptIntCallback,
20 | |     RGBCallback,
21 | | )
   | |_^
22 |   if TYPE_CHECKING:
23 |       from .bridge_controller import BridgeController as _BridgeControllerHint
   |

F401 [*] `.types.BridgeController` imported but unused
  --> bb8_core/ble_bridge.py:14:5
   |
12 | from typing import Optional, Any, List, Tuple, TYPE_CHECKING
13 | from .types import (
14 |     BridgeController,
   |     ^^^^^^^^^^^^^^^^
15 |     BLELink,
16 |     MqttClient,
   |
help: Remove unused import

F401 [*] `.types.BLELink` imported but unused
  --> bb8_core/ble_bridge.py:15:5
   |
13 | from .types import (
14 |     BridgeController,
15 |     BLELink,
   |     ^^^^^^^
16 |     MqttClient,
17 |     BoolCallback,
   |
help: Remove unused import

F401 [*] `.types.MqttClient` imported but unused
  --> bb8_core/ble_bridge.py:16:5
   |
14 |     BridgeController,
15 |     BLELink,
16 |     MqttClient,
   |     ^^^^^^^^^^
17 |     BoolCallback,
18 |     IntCallback,
   |
help: Remove unused import

F401 [*] `.types.BoolCallback` imported but unused
  --> bb8_core/ble_bridge.py:17:5
   |
15 |     BLELink,
16 |     MqttClient,
17 |     BoolCallback,
   |     ^^^^^^^^^^^^
18 |     IntCallback,
19 |     OptIntCallback,
   |
help: Remove unused import

F401 [*] `.types.IntCallback` imported but unused
  --> bb8_core/ble_bridge.py:18:5
   |
16 |     MqttClient,
17 |     BoolCallback,
18 |     IntCallback,
   |     ^^^^^^^^^^^
19 |     OptIntCallback,
20 |     RGBCallback,
   |
help: Remove unused import

F401 [*] `.types.OptIntCallback` imported but unused
  --> bb8_core/ble_bridge.py:19:5
   |
17 |     BoolCallback,
18 |     IntCallback,
19 |     OptIntCallback,
   |     ^^^^^^^^^^^^^^
20 |     RGBCallback,
21 | )
   |
help: Remove unused import

F401 [*] `.types.RGBCallback` imported but unused
  --> bb8_core/ble_bridge.py:20:5
   |
18 |     IntCallback,
19 |     OptIntCallback,
20 |     RGBCallback,
   |     ^^^^^^^^^^^
21 | )
22 | if TYPE_CHECKING:
   |
help: Remove unused import

F401 [*] `.bridge_controller.BridgeController` imported but unused
  --> bb8_core/ble_bridge.py:23:56
   |
21 | )
22 | if TYPE_CHECKING:
23 |     from .bridge_controller import BridgeController as _BridgeControllerHint
   |                                                        ^^^^^^^^^^^^^^^^^^^^^
24 | import asyncio
25 | import importlib.metadata
   |
help: Remove unused import: `.bridge_controller.BridgeController`

E402 Module level import not at top of file
  --> bb8_core/ble_bridge.py:24:1
   |
22 | if TYPE_CHECKING:
23 |     from .bridge_controller import BridgeController as _BridgeControllerHint
24 | import asyncio
   | ^^^^^^^^^^^^^^
25 | import importlib.metadata
26 | import json
   |

I001 [*] Import block is un-sorted or un-formatted
  --> bb8_core/ble_bridge.py:24:1
   |
22 |   if TYPE_CHECKING:
23 |       from .bridge_controller import BridgeController as _BridgeControllerHint
24 | / import asyncio
25 | | import importlib.metadata
26 | | import json
27 | | import os
28 | | import time
29 | |
30 | | from bleak import BleakClient
31 | | from bleak.exc import BleakCharacteristicNotFoundError
32 | | import paho.mqtt.publish as publish
   | |___________________________________^
33 |
34 |   REQUIRE_DEVICE_ECHO = os.environ.get("REQUIRE_DEVICE_ECHO", "1") not in ("0", "false", "no", "off")
   |
help: Organize imports

E402 Module level import not at top of file
  --> bb8_core/ble_bridge.py:25:1
   |
23 |     from .bridge_controller import BridgeController as _BridgeControllerHint
24 | import asyncio
25 | import importlib.metadata
   | ^^^^^^^^^^^^^^^^^^^^^^^^^
26 | import json
27 | import os
   |

E402 Module level import not at top of file
  --> bb8_core/ble_bridge.py:26:1
   |
24 | import asyncio
25 | import importlib.metadata
26 | import json
   | ^^^^^^^^^^^
27 | import os
28 | import time
   |

E402 Module level import not at top of file
  --> bb8_core/ble_bridge.py:27:1
   |
25 | import importlib.metadata
26 | import json
27 | import os
   | ^^^^^^^^^
28 | import time
   |

E402 Module level import not at top of file
  --> bb8_core/ble_bridge.py:28:1
   |
26 | import json
27 | import os
28 | import time
   | ^^^^^^^^^^^
29 |
30 | from bleak import BleakClient
   |

E402 Module level import not at top of file
  --> bb8_core/ble_bridge.py:30:1
   |
28 | import time
29 |
30 | from bleak import BleakClient
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
31 | from bleak.exc import BleakCharacteristicNotFoundError
32 | import paho.mqtt.publish as publish
   |

E402 Module level import not at top of file
  --> bb8_core/ble_bridge.py:31:1
   |
30 | from bleak import BleakClient
31 | from bleak.exc import BleakCharacteristicNotFoundError
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
32 | import paho.mqtt.publish as publish
   |

E402 Module level import not at top of file
  --> bb8_core/ble_bridge.py:32:1
   |
30 | from bleak import BleakClient
31 | from bleak.exc import BleakCharacteristicNotFoundError
32 | import paho.mqtt.publish as publish
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
33 |
34 | REQUIRE_DEVICE_ECHO = os.environ.get("REQUIRE_DEVICE_ECHO", "1") not in ("0", "false", "no", "off")
   |

E501 Line too long (99 > 88)
  --> bb8_core/ble_bridge.py:34:89
   |
32 | import paho.mqtt.publish as publish
33 |
34 | REQUIRE_DEVICE_ECHO = os.environ.get("REQUIRE_DEVICE_ECHO", "1") not in ("0", "false", "no", "off")
   |                                                                                         ^^^^^^^^^^^
35 |
36 | from .logging_setup import logger
   |

E402 Module level import not at top of file
  --> bb8_core/ble_bridge.py:36:1
   |
34 | REQUIRE_DEVICE_ECHO = os.environ.get("REQUIRE_DEVICE_ECHO", "1") not in ("0", "false", "no", "off")
35 |
36 | from .logging_setup import logger
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
37 | from spherov2.adapter.bleak_adapter import BleakAdapter
38 | from spherov2.commands.core import IntervalOptions
   |

I001 [*] Import block is un-sorted or un-formatted
  --> bb8_core/ble_bridge.py:36:1
   |
34 |   REQUIRE_DEVICE_ECHO = os.environ.get("REQUIRE_DEVICE_ECHO", "1") not in ("0", "false", "no", "off")
35 |
36 | / from .logging_setup import logger
37 | | from spherov2.adapter.bleak_adapter import BleakAdapter
38 | | from spherov2.commands.core import IntervalOptions
39 | | from spherov2.scanner import find_toys
40 | | from spherov2.toy.bb8 import BB8
41 | |
42 | | from .ble_utils import resolve_services
43 | | from .core import Core
   | |______________________^
   |
help: Organize imports

E402 Module level import not at top of file
  --> bb8_core/ble_bridge.py:37:1
   |
36 | from .logging_setup import logger
37 | from spherov2.adapter.bleak_adapter import BleakAdapter
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
38 | from spherov2.commands.core import IntervalOptions
39 | from spherov2.scanner import find_toys
   |

E402 Module level import not at top of file
  --> bb8_core/ble_bridge.py:38:1
   |
36 | from .logging_setup import logger
37 | from spherov2.adapter.bleak_adapter import BleakAdapter
38 | from spherov2.commands.core import IntervalOptions
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
39 | from spherov2.scanner import find_toys
40 | from spherov2.toy.bb8 import BB8
   |

E402 Module level import not at top of file
  --> bb8_core/ble_bridge.py:39:1
   |
37 | from spherov2.adapter.bleak_adapter import BleakAdapter
38 | from spherov2.commands.core import IntervalOptions
39 | from spherov2.scanner import find_toys
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
40 | from spherov2.toy.bb8 import BB8
   |

E402 Module level import not at top of file
  --> bb8_core/ble_bridge.py:40:1
   |
38 | from spherov2.commands.core import IntervalOptions
39 | from spherov2.scanner import find_toys
40 | from spherov2.toy.bb8 import BB8
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
41 |
42 | from .ble_utils import resolve_services
   |

E402 Module level import not at top of file
  --> bb8_core/ble_bridge.py:42:1
   |
40 | from spherov2.toy.bb8 import BB8
41 |
42 | from .ble_utils import resolve_services
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
43 | from .core import Core
   |

E402 Module level import not at top of file
  --> bb8_core/ble_bridge.py:43:1
   |
42 | from .ble_utils import resolve_services
43 | from .core import Core
   | ^^^^^^^^^^^^^^^^^^^^^^
   |

E501 Line too long (93 > 88)
  --> bb8_core/ble_bridge.py:58:89
   |
56 | except Exception:
57 |     spherov2_version = "unknown"
58 | logger.info({"event": "version_probe", "bleak": bleak_version, "spherov2": spherov2_version})
   |                                                                                         ^^^^^
59 |
60 | class BLEBridge:
   |

E501 Line too long (109 > 88)
  --> bb8_core/ble_bridge.py:64:89
   |
62 |     def set_heading(self, degrees: int) -> None:
63 |         if REQUIRE_DEVICE_ECHO:
64 |             logger.warning({"event": "shim_disabled", "reason": "REQUIRE_DEVICE_ECHO=1", "topic": "heading"})
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^
65 |             return
66 |         try:
   |

E501 Line too long (107 > 88)
  --> bb8_core/ble_bridge.py:79:89
   |
77 |     def set_speed(self, speed: int) -> None:
78 |         if REQUIRE_DEVICE_ECHO:
79 |             logger.warning({"event": "shim_disabled", "reason": "REQUIRE_DEVICE_ECHO=1", "topic": "speed"})
   |                                                                                         ^^^^^^^^^^^^^^^^^^^
80 |             return
81 |         try:
   |

E501 Line too long (107 > 88)
  --> bb8_core/ble_bridge.py:94:89
   |
92 |     def drive(self, heading: int, speed: int) -> None:
93 |         if REQUIRE_DEVICE_ECHO:
94 |             logger.warning({"event": "shim_disabled", "reason": "REQUIRE_DEVICE_ECHO=1", "topic": "drive"})
   |                                                                                         ^^^^^^^^^^^^^^^^^^^
95 |             return
96 |         try:
   |

E501 Line too long (93 > 88)
  --> bb8_core/ble_bridge.py:97:89
   |
95 |             return
96 |         try:
97 |             logger.info({"event": "ble_drive", "heading": int(heading), "speed": int(speed)})
   |                                                                                         ^^^^^
98 |             # TODO: spherov2 roll for a short burst
99 |             # Publish scalar echoes for heading and speed
   |

E501 Line too long (94 > 88)
   --> bb8_core/ble_bridge.py:102:89
    |
100 |             from .mqtt_echo import echo_scalar
101 |             if hasattr(self, "_mqtt") and self._mqtt.get("client"):
102 |                 echo_scalar(self._mqtt["client"], self._mqtt["base"], "heading", int(heading))
    |                                                                                         ^^^^^^
103 |                 echo_scalar(self._mqtt["client"], self._mqtt["base"], "speed", int(speed))
104 |         except Exception as e:
    |

E501 Line too long (90 > 88)
   --> bb8_core/ble_bridge.py:103:89
    |
101 |             if hasattr(self, "_mqtt") and self._mqtt.get("client"):
102 |                 echo_scalar(self._mqtt["client"], self._mqtt["base"], "heading", int(heading))
103 |                 echo_scalar(self._mqtt["client"], self._mqtt["base"], "speed", int(speed))
    |                                                                                         ^^
104 |         except Exception as e:
105 |             logger.error({"event": "ble_drive_error", "error": repr(e)})
    |

E501 Line too long (90 > 88)
   --> bb8_core/ble_bridge.py:128:89
    |
126 |             try:
127 |                 if not getattr(self, "_toy", None):
128 |                     logger.info({"event": "ble_stop_noop", "reason": "toy_not_connected"})
    |                                                                                         ^^
129 |                     return
130 |                 # TODO: implement real stop via spherov2
    |

E702 Multiple statements on one line (semicolon)
   --> bb8_core/ble_bridge.py:145:37
    |
143 |     def set_led_rgb(self, r: int, g: int, b: int) -> None:
144 |         """Set LED color; clamps inputs; safe no-op if not connected."""
145 |         r = max(0, min(255, int(r))); g = max(0, min(255, int(g))); b = max(0, min(255, int(b)))
    |                                     ^
146 |         with self._lock:
147 |             try:
    |

E702 Multiple statements on one line (semicolon)
   --> bb8_core/ble_bridge.py:145:67
    |
143 |     def set_led_rgb(self, r: int, g: int, b: int) -> None:
144 |         """Set LED color; clamps inputs; safe no-op if not connected."""
145 |         r = max(0, min(255, int(r))); g = max(0, min(255, int(g))); b = max(0, min(255, int(b)))
    |                                                                   ^
146 |         with self._lock:
147 |             try:
    |

E501 Line too long (96 > 88)
   --> bb8_core/ble_bridge.py:145:89
    |
143 |     def set_led_rgb(self, r: int, g: int, b: int) -> None:
144 |         """Set LED color; clamps inputs; safe no-op if not connected."""
145 |         r = max(0, min(255, int(r))); g = max(0, min(255, int(g))); b = max(0, min(255, int(b)))
    |                                                                                         ^^^^^^^^
146 |         with self._lock:
147 |             try:
    |

E501 Line too long (113 > 88)
   --> bb8_core/ble_bridge.py:149:89
    |
147 |             try:
148 |                 if not getattr(self, "_toy", None):
149 |                     logger.info({"event": "ble_led_noop", "reason": "toy_not_connected", "r": r, "g": g, "b": b})
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^
150 |                     return
151 |                 # TODO: implement real LED set via spherov2
    |

E501 Line too long (98 > 88)
   --> bb8_core/ble_bridge.py:154:89
    |
152 |                 logger.info({"event": "ble_led_set", "r": r, "g": g, "b": b})
153 |             except Exception as e:
154 |                 logger.error({"event": "ble_led_error", "r": r, "g": g, "b": b, "error": repr(e)})
    |                                                                                         ^^^^^^^^^^
155 |
156 |     def sleep(self, after_ms: Optional[int] = None) -> None:
    |

E501 Line too long (113 > 88)
   --> bb8_core/ble_bridge.py:161:89
    |
159 |             try:
160 |                 if not getattr(self, "_toy", None):
161 |                     logger.info({"event": "ble_sleep_noop", "reason": "toy_not_connected", "after_ms": after_ms})
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^
162 |                     return
163 |                 # TODO: implement real sleep via spherov2 (respect after_ms if desired)
    |

E501 Line too long (126 > 88)
   --> bb8_core/ble_bridge.py:168:89
    |
166 |                 from .mqtt_echo import echo_scalar
167 |                 if hasattr(self, "_mqtt") and self._mqtt.get("client"):
168 |                     echo_scalar(self._mqtt["client"], self._mqtt["base"], "sleep", after_ms if after_ms is not None else True)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
169 |             except Exception as e:
170 |                 logger.error({"event": "ble_sleep_error", "after_ms": after_ms, "error": repr(e)})
    |

E501 Line too long (98 > 88)
   --> bb8_core/ble_bridge.py:170:89
    |
168 |                     echo_scalar(self._mqtt["client"], self._mqtt["base"], "sleep", after_ms if after_ms is not None else True)
169 |             except Exception as e:
170 |                 logger.error({"event": "ble_sleep_error", "after_ms": after_ms, "error": repr(e)})
    |                                                                                         ^^^^^^^^^^
171 |
172 |     def is_connected(self) -> bool:
    |

E501 Line too long (94 > 88)
   --> bb8_core/ble_bridge.py:187:89
    |
185 |             logger.debug({"event": "ble_get_rssi_error", "error": repr(e)})
186 |         return 0
187 |     def attach_mqtt(self, client, base_topic: str, qos: int = 1, retain: bool = True) -> None:
    |                                                                                         ^^^^^^
188 |         """
189 |         Wire MQTT subscriptions for commands and set up state publishers.
    |

E501 Line too long (110 > 88)
   --> bb8_core/ble_bridge.py:192:89
    |
190 |         Expected topics (under base_topic):
191 |           - power:    {base}/power/set   (payload: "ON"|"OFF")    -> {base}/power/state
192 |           - stop:     {base}/stop/press  (payload: any)           -> {base}/stop/state ("pressed" then "idle")
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^
193 |           - led:      {base}/led/set     (json: {"r":..,"g":..,"b":..} or {"hex":"#rrggbb"} or "OFF")
194 |                       -> {base}/led/state (json {"r":..,"g":..,"b":..} or {"state":"OFF"})
    |

E501 Line too long (101 > 88)
   --> bb8_core/ble_bridge.py:193:89
    |
191 |           - power:    {base}/power/set   (payload: "ON"|"OFF")    -> {base}/power/state
192 |           - stop:     {base}/stop/press  (payload: any)           -> {base}/stop/state ("pressed" then "idle")
193 |           - led:      {base}/led/set     (json: {"r":..,"g":..,"b":..} or {"hex":"#rrggbb"} or "OFF")
    |                                                                                         ^^^^^^^^^^^^^
194 |                       -> {base}/led/state (json {"r":..,"g":..,"b":..} or {"state":"OFF"})
195 |         Telemetry publishers (you can call these from your periodic loop):
    |

E501 Line too long (90 > 88)
   --> bb8_core/ble_bridge.py:194:89
    |
192 |           - stop:     {base}/stop/press  (payload: any)           -> {base}/stop/state ("pressed" then "idle")
193 |           - led:      {base}/led/set     (json: {"r":..,"g":..,"b":..} or {"hex":"#rrggbb"} or "OFF")
194 |                       -> {base}/led/state (json {"r":..,"g":..,"b":..} or {"state":"OFF"})
    |                                                                                         ^^
195 |         Telemetry publishers (you can call these from your periodic loop):
196 |           - presence: {base}/presence/state  ("ON"|"OFF")
    |

I001 [*] Import block is un-sorted or un-formatted
   --> bb8_core/ble_bridge.py:199:9
    |
197 |             - rssi:     {base}/rssi/state      (int dBm)
198 |           """
199 | /         from .logging_setup import logger
200 | |         import json
201 | |         import threading
202 | |         import time
    | |___________________^
203 |
204 |           self._mqtt = {"client": client, "base": base_topic, "qos": qos, "retain": retain}
    |
help: Organize imports

E501 Line too long (89 > 88)
   --> bb8_core/ble_bridge.py:204:89
    |
202 |         import time
203 |
204 |         self._mqtt = {"client": client, "base": base_topic, "qos": qos, "retain": retain}
    |                                                                                         ^
205 |
206 |         def _pub(topic_suffix: str, payload, r: bool = retain):
    |

E501 Line too long (94 > 88)
   --> bb8_core/ble_bridge.py:230:89
    |
228 |                     logger.info({"event": "ble_cmd_power_state_echo", "state": "OFF"})
229 |                 else:
230 |                     logger.warning({"event": "ble_cmd_power_invalid_payload", "payload": val})
    |                                                                                         ^^^^^^
231 |             except Exception as e:
232 |                 logger.error({"event": "ble_cmd_power_handler_error", "error": repr(e)})
    |

E501 Line too long (97 > 88)
   --> bb8_core/ble_bridge.py:243:89
    |
241 |                     if "hex" in obj and isinstance(obj["hex"], str):
242 |                         h = obj["hex"].lstrip("#")
243 |                         return {"r": int(h[0:2], 16), "g": int(h[2:4], 16), "b": int(h[4:6], 16)}
    |                                                                                         ^^^^^^^^^
244 |                     r = int(obj.get("r", 0)); g = int(obj.get("g", 0)); b = int(obj.get("b", 0))
245 |                     return {"r": max(0, min(255, r)), "g": max(0, min(255, g)), "b": max(0, min(255, b))}
    |

E702 Multiple statements on one line (semicolon)
   --> bb8_core/ble_bridge.py:244:45
    |
242 |                         h = obj["hex"].lstrip("#")
243 |                         return {"r": int(h[0:2], 16), "g": int(h[2:4], 16), "b": int(h[4:6], 16)}
244 |                     r = int(obj.get("r", 0)); g = int(obj.get("g", 0)); b = int(obj.get("b", 0))
    |                                             ^
245 |                     return {"r": max(0, min(255, r)), "g": max(0, min(255, g)), "b": max(0, min(255, b))}
246 |             except Exception:
    |

E702 Multiple statements on one line (semicolon)
   --> bb8_core/ble_bridge.py:244:71
    |
242 |                         h = obj["hex"].lstrip("#")
243 |                         return {"r": int(h[0:2], 16), "g": int(h[2:4], 16), "b": int(h[4:6], 16)}
244 |                     r = int(obj.get("r", 0)); g = int(obj.get("g", 0)); b = int(obj.get("b", 0))
    |                                                                       ^
245 |                     return {"r": max(0, min(255, r)), "g": max(0, min(255, g)), "b": max(0, min(255, b))}
246 |             except Exception:
    |

E501 Line too long (96 > 88)
   --> bb8_core/ble_bridge.py:244:89
    |
242 |                         h = obj["hex"].lstrip("#")
243 |                         return {"r": int(h[0:2], 16), "g": int(h[2:4], 16), "b": int(h[4:6], 16)}
244 |                     r = int(obj.get("r", 0)); g = int(obj.get("g", 0)); b = int(obj.get("b", 0))
    |                                                                                         ^^^^^^^^
245 |                     return {"r": max(0, min(255, r)), "g": max(0, min(255, g)), "b": max(0, min(255, b))}
246 |             except Exception:
    |

E501 Line too long (105 > 88)
   --> bb8_core/ble_bridge.py:245:89
    |
243 |                         return {"r": int(h[0:2], 16), "g": int(h[2:4], 16), "b": int(h[4:6], 16)}
244 |                     r = int(obj.get("r", 0)); g = int(obj.get("g", 0)); b = int(obj.get("b", 0))
245 |                     return {"r": max(0, min(255, r)), "g": max(0, min(255, g)), "b": max(0, min(255, b))}
    |                                                                                         ^^^^^^^^^^^^^^^^^
246 |             except Exception:
247 |                 pass
    |

E501 Line too long (110 > 88)
   --> bb8_core/ble_bridge.py:263:89
    |
261 |                 else:
262 |                     if hasattr(self, "set_led_rgb"):
263 |                         logger.info({"event": "ble_cmd_led_rgb", "r": rgb["r"], "g": rgb["g"], "b": rgb["b"]})
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^
264 |                         self.set_led_rgb(rgb["r"], rgb["g"], rgb["b"])
265 |                     _pub("led/state", {"r": rgb["r"], "g": rgb["g"], "b": rgb["b"]})
    |

E501 Line too long (113 > 88)
   --> bb8_core/ble_bridge.py:266:89
    |
264 |                         self.set_led_rgb(rgb["r"], rgb["g"], rgb["b"])
265 |                     _pub("led/state", {"r": rgb["r"], "g": rgb["g"], "b": rgb["b"]})
266 |                     logger.info({"event": "ble_cmd_led_state_echo", "r": rgb["r"], "g": rgb["g"], "b": rgb["b"]})
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^
267 |             except Exception as e:
268 |                 logger.error({"event": "ble_cmd_led_handler_error", "error": repr(e)})
    |

E501 Line too long (98 > 88)
   --> bb8_core/ble_bridge.py:306:89
    |
304 |         self.publish_presence = publish_presence  # type: ignore[attr-defined]
305 |         self.publish_rssi = publish_rssi          # type: ignore[attr-defined]
306 |         def attach_mqtt(self, client, base_topic: str, qos: int = 1, retain: bool = True) -> None:
    |                                                                                         ^^^^^^^^^^
307 |             """Deprecated: forwarding to facade to avoid transport concerns in bridge."""
308 |             from .facade import BB8Facade  # lazy import to avoid circular import
    |

E501 Line too long (89 > 88)
   --> bb8_core/ble_bridge.py:307:89
    |
305 |         self.publish_rssi = publish_rssi          # type: ignore[attr-defined]
306 |         def attach_mqtt(self, client, base_topic: str, qos: int = 1, retain: bool = True) -> None:
307 |             """Deprecated: forwarding to facade to avoid transport concerns in bridge."""
    |                                                                                         ^
308 |             from .facade import BB8Facade  # lazy import to avoid circular import
309 |             BB8Facade(self).attach_mqtt(client, base_topic, qos=qos, retain=retain)
    |

E501 Line too long (111 > 88)
   --> bb8_core/ble_bridge.py:310:89
    |
308 |             from .facade import BB8Facade  # lazy import to avoid circular import
309 |             BB8Facade(self).attach_mqtt(client, base_topic, qos=qos, retain=retain)
310 |     def __init__(self, gateway, target_mac: Optional[str] = None, mac: Optional[str] = None, **kwargs) -> None:
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^
311 |         import threading
312 |         self._lock = threading.RLock()
    |

E501 Line too long (89 > 88)
   --> bb8_core/ble_bridge.py:324:89
    |
322 |         self.controller: Optional[Any] = kwargs.get("controller")
323 |         # Low-level core
324 |         self.core = Core(address=self.target_mac, adapter=self.gateway.resolve_adapter())
    |                                                                                         ^
325 |         logger.debug({"event": "ble_bridge_init", "mac": self.target_mac, "adapter": self.gateway.resolve_adapter()})
    |

E501 Line too long (117 > 88)
   --> bb8_core/ble_bridge.py:325:89
    |
323 |         # Low-level core
324 |         self.core = Core(address=self.target_mac, adapter=self.gateway.resolve_adapter())
325 |         logger.debug({"event": "ble_bridge_init", "mac": self.target_mac, "adapter": self.gateway.resolve_adapter()})
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
326 |
327 |     def connect_bb8(self):
    |

E501 Line too long (94 > 88)
   --> bb8_core/ble_bridge.py:333:89
    |
331 |             logger.debug({"event": "connect_bb8_scan_result", "device": str(device)})
332 |             if not device:
333 |                 msg = "BB-8 not found. Please tap robot or remove from charger and try again."
    |                                                                                         ^^^^^^
334 |                 publish_bb8_error(msg)
335 |                 logger.error({"event": "connect_bb8_not_found", "msg": msg})
    |

E501 Line too long (133 > 88)
   --> bb8_core/ble_bridge.py:338:89
    |
336 |                 return None
337 |             if self.controller is not None:
338 |                 logger.debug({"event": "connect_bb8_attach_device", "controller": str(type(self.controller)), "device": str(device)})
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
339 |                 self.controller.attach_device(device)
340 |             else:
    |

E501 Line too long (107 > 88)
   --> bb8_core/ble_bridge.py:344:89
    |
342 |                 return None
343 |             if not hasattr(device, 'services') or not any(
344 |                 '22bb746f-2bbd-7554-2d6f-726568705327' in str(s) for s in getattr(device, 'services', [])):
    |                                                                                         ^^^^^^^^^^^^^^^^^^^
345 |                 msg = "BB-8 not awake. Please tap robot or remove from charger and try again."
346 |                 publish_bb8_error(msg)
    |

E501 Line too long (94 > 88)
   --> bb8_core/ble_bridge.py:345:89
    |
343 |             if not hasattr(device, 'services') or not any(
344 |                 '22bb746f-2bbd-7554-2d6f-726568705327' in str(s) for s in getattr(device, 'services', [])):
345 |                 msg = "BB-8 not awake. Please tap robot or remove from charger and try again."
    |                                                                                         ^^^^^^
346 |                 publish_bb8_error(msg)
347 |                 logger.error({"event": "connect_bb8_not_awake", "msg": msg, "device": str(device)})
    |

E501 Line too long (99 > 88)
   --> bb8_core/ble_bridge.py:347:89
    |
345 |                 msg = "BB-8 not awake. Please tap robot or remove from charger and try again."
346 |                 publish_bb8_error(msg)
347 |                 logger.error({"event": "connect_bb8_not_awake", "msg": msg, "device": str(device)})
    |                                                                                         ^^^^^^^^^^^
348 |                 raise BleakCharacteristicNotFoundError('22bb746f-2bbd-7554-2d6f-726568705327')
349 |             logger.info({"event": "connect_bb8_success", "device": str(device)})
    |

E501 Line too long (94 > 88)
   --> bb8_core/ble_bridge.py:348:89
    |
346 |                 publish_bb8_error(msg)
347 |                 logger.error({"event": "connect_bb8_not_awake", "msg": msg, "device": str(device)})
348 |                 raise BleakCharacteristicNotFoundError('22bb746f-2bbd-7554-2d6f-726568705327')
    |                                                                                         ^^^^^^
349 |             logger.info({"event": "connect_bb8_success", "device": str(device)})
350 |             return device
    |

E501 Line too long (125 > 88)
   --> bb8_core/ble_bridge.py:367:89
    |
365 |             return None
366 |         if self.controller is not None:
367 |             logger.debug({"event": "connect_attach_device", "controller": str(type(self.controller)), "device": str(device)})
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
368 |             self.controller.attach_device(device)
369 |         else:
    |

E501 Line too long (90 > 88)
   --> bb8_core/ble_bridge.py:447:89
    |
445 |         if hasattr(bb8, 'set_main_led'):
446 |             bb8.set_main_led(255, 255, 255, None)
447 |             logger.info(f"[BB-8] LED command succeeded in {time.time() - led_start:.2f}s")
    |                                                                                         ^^
448 |         else:
449 |             logger.warning("[BB-8] Device does not support set_main_led.")
    |

E501 Line too long (114 > 88)
   --> bb8_core/ble_bridge.py:451:89
    |
449 |             logger.warning("[BB-8] Device does not support set_main_led.")
450 |     except Exception as e:
451 |         logger.error(f"[BB-8][ERROR] LED command failed after {time.time() - led_start:.2f}s: {e}", exc_info=True)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
452 |         logger.info(f"[BB-8] Status after LED error: is_connected={getattr(bb8, 'is_connected', None)}")
453 |         return
    |

E501 Line too long (104 > 88)
   --> bb8_core/ble_bridge.py:452:89
    |
450 |     except Exception as e:
451 |         logger.error(f"[BB-8][ERROR] LED command failed after {time.time() - led_start:.2f}s: {e}", exc_info=True)
452 |         logger.info(f"[BB-8] Status after LED error: is_connected={getattr(bb8, 'is_connected', None)}")
    |                                                                                         ^^^^^^^^^^^^^^^^
453 |         return
454 |     roll_start = time.time()
    |

E501 Line too long (92 > 88)
   --> bb8_core/ble_bridge.py:458:89
    |
456 |         if hasattr(bb8, 'roll'):
457 |             bb8.roll(30, 0, 1000)  # speed, heading, duration_ms
458 |             logger.info(f"[BB-8] Roll command succeeded in {time.time() - roll_start:.2f}s")
    |                                                                                         ^^^^
459 |         else:
460 |             logger.warning("[BB-8] Device does not support roll.")
    |

E501 Line too long (116 > 88)
   --> bb8_core/ble_bridge.py:462:89
    |
460 |             logger.warning("[BB-8] Device does not support roll.")
461 |     except Exception as e:
462 |         logger.error(f"[BB-8][ERROR] Roll command failed after {time.time() - roll_start:.2f}s: {e}", exc_info=True)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
463 |         logger.info(f"[BB-8] Status after roll error: is_connected={getattr(bb8, 'is_connected', None)}")
464 |         return
    |

E501 Line too long (105 > 88)
   --> bb8_core/ble_bridge.py:463:89
    |
461 |     except Exception as e:
462 |         logger.error(f"[BB-8][ERROR] Roll command failed after {time.time() - roll_start:.2f}s: {e}", exc_info=True)
463 |         logger.info(f"[BB-8] Status after roll error: is_connected={getattr(bb8, 'is_connected', None)}")
    |                                                                                         ^^^^^^^^^^^^^^^^^
464 |         return
    |

E501 Line too long (94 > 88)
   --> bb8_core/ble_bridge.py:488:89
    |
486 |             try:
487 |                 bb8.set_main_led(0, 100, 255, None)
488 |                 logger.info(f"[BB-8] LED command succeeded in {time.time() - led_start:.2f}s")
    |                                                                                         ^^^^^^
489 |             except Exception as e:
490 |                 logger.error(f"[BB-8][ERROR] LED command failed after {time.time() - led_start:.2f}s: {e}", exc_info=True)
    |

E501 Line too long (122 > 88)
   --> bb8_core/ble_bridge.py:490:89
    |
488 |                 logger.info(f"[BB-8] LED command succeeded in {time.time() - led_start:.2f}s")
489 |             except Exception as e:
490 |                 logger.error(f"[BB-8][ERROR] LED command failed after {time.time() - led_start:.2f}s: {e}", exc_info=True)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
491 |                 logger.info(f"[BB-8] Status after LED error: is_connected={getattr(bb8, 'is_connected', None)}")
492 |                 return
    |

E501 Line too long (112 > 88)
   --> bb8_core/ble_bridge.py:491:89
    |
489 |             except Exception as e:
490 |                 logger.error(f"[BB-8][ERROR] LED command failed after {time.time() - led_start:.2f}s: {e}", exc_info=True)
491 |                 logger.info(f"[BB-8] Status after LED error: is_connected={getattr(bb8, 'is_connected', None)}")
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^
492 |                 return
493 |             for i in reversed(range(0, 101, 20)):
    |

E501 Line too long (101 > 88)
   --> bb8_core/ble_bridge.py:498:89
    |
496 |                     logger.info(f"[BB-8] Setting LED: (0, {i}, {int(2.55 * i)})")
497 |                     bb8.set_main_led(0, i, int(2.55 * i), None)
498 |                     logger.info(f"[BB-8] LED fade step succeeded in {time.time() - fade_start:.2f}s")
    |                                                                                         ^^^^^^^^^^^^^
499 |                 except Exception as e:
500 |                     logger.error(f"[BB-8][ERROR] LED fade step failed after {time.time() - fade_start:.2f}s: {e}", exc_info=True)
    |

E501 Line too long (129 > 88)
   --> bb8_core/ble_bridge.py:500:89
    |
498 |                     logger.info(f"[BB-8] LED fade step succeeded in {time.time() - fade_start:.2f}s")
499 |                 except Exception as e:
500 |                     logger.error(f"[BB-8][ERROR] LED fade step failed after {time.time() - fade_start:.2f}s: {e}", exc_info=True)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
501 |                     logger.info(f"[BB-8] Status after fade error: is_connected={getattr(bb8, 'is_connected', None)}")
502 |                     return
    |

E501 Line too long (117 > 88)
   --> bb8_core/ble_bridge.py:501:89
    |
499 |                 except Exception as e:
500 |                     logger.error(f"[BB-8][ERROR] LED fade step failed after {time.time() - fade_start:.2f}s: {e}", exc_info=True)
501 |                     logger.info(f"[BB-8] Status after fade error: is_connected={getattr(bb8, 'is_connected', None)}")
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
502 |                     return
503 |                 time.sleep(0.15)
    |

E501 Line too long (126 > 88)
   --> bb8_core/ble_bridge.py:509:89
    |
507 |                 logger.info(f"[BB-8] After LED off in {time.time() - off_start:.2f}s")
508 |             except Exception as e:
509 |                 logger.error(f"[BB-8][ERROR] LED off command failed after {time.time() - off_start:.2f}s: {e}", exc_info=True)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
510 |                 logger.info(f"[BB-8] Status after LED off error: is_connected={getattr(bb8, 'is_connected', None)}")
511 |                 return
    |

E501 Line too long (116 > 88)
   --> bb8_core/ble_bridge.py:510:89
    |
508 |             except Exception as e:
509 |                 logger.error(f"[BB-8][ERROR] LED off command failed after {time.time() - off_start:.2f}s: {e}", exc_info=True)
510 |                 logger.info(f"[BB-8] Status after LED off error: is_connected={getattr(bb8, 'is_connected', None)}")
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
511 |                 return
512 |             sleep_start = time.time()
    |

E501 Line too long (126 > 88)
   --> bb8_core/ble_bridge.py:517:89
    |
515 |                 logger.info(f"[BB-8] After sleep in {time.time() - sleep_start:.2f}s")
516 |             except Exception as e:
517 |                 logger.error(f"[BB-8][ERROR] Sleep command failed after {time.time() - sleep_start:.2f}s: {e}", exc_info=True)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
518 |                 logger.info(f"[BB-8] Status after sleep error: is_connected={getattr(bb8, 'is_connected', None)}")
519 |                 return
    |

E501 Line too long (114 > 88)
   --> bb8_core/ble_bridge.py:518:89
    |
516 |             except Exception as e:
517 |                 logger.error(f"[BB-8][ERROR] Sleep command failed after {time.time() - sleep_start:.2f}s: {e}", exc_info=True)
518 |                 logger.info(f"[BB-8] Status after sleep error: is_connected={getattr(bb8, 'is_connected', None)}")
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
519 |                 return
520 |         logger.info("[BB-8] Power OFF sequence: complete.")
    |

E501 Line too long (90 > 88)
   --> bb8_core/ble_bridge.py:522:89
    |
520 |         logger.info("[BB-8] Power OFF sequence: complete.")
521 |     except Exception as e:
522 |         logger.error(f"[BB-8][ERROR] Exception in power OFF sequence: {e}", exc_info=True)
    |                                                                                         ^^
523 |
524 | def publish_bb8_error(msg):
    |

E501 Line too long (90 > 88)
   --> bb8_core/ble_bridge.py:532:89
    |
530 |         logger.error(f"[BB-8][ERROR] Failed to publish error to MQTT: {e}")
531 |
532 | def ble_command_with_retry(cmd_func, max_attempts=4, initial_cooldown=3, *args, **kwargs):
    |                                                                                         ^^
533 |     cooldown = initial_cooldown
534 |     for attempt in range(1, max_attempts + 1):
    |

E501 Line too long (91 > 88)
   --> bb8_core/ble_bridge.py:536:89
    |
534 |     for attempt in range(1, max_attempts + 1):
535 |         try:
536 |             logger.info(f"[BB-8] Attempt {attempt}/{max_attempts} for {cmd_func.__name__}")
    |                                                                                         ^^^
537 |             result = cmd_func(*args, **kwargs)
538 |             logger.info(f"[BB-8] {cmd_func.__name__} succeeded on attempt {attempt}")
    |

E501 Line too long (110 > 88)
   --> bb8_core/ble_bridge.py:541:89
    |
539 |             return result
540 |         except Exception as e:
541 |             logger.error(f"[BB-8][ERROR] {cmd_func.__name__} failed on attempt {attempt}: {e}", exc_info=True)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^
542 |             publish_bb8_error(str(e))
543 |             if attempt < max_attempts:
    |

E501 Line too long (100 > 88)
   --> bb8_core/ble_bridge.py:548:89
    |
546 |                 cooldown *= 2
547 |             else:
548 |                 logger.critical(f"[BB-8] {cmd_func.__name__} failed after {max_attempts} attempts.")
    |                                                                                         ^^^^^^^^^^^^
549 |                 publish_bb8_error(f"{cmd_func.__name__} failed after {max_attempts} attempts: {e}")
550 |     return None
    |

E501 Line too long (99 > 88)
   --> bb8_core/ble_bridge.py:549:89
    |
547 |             else:
548 |                 logger.critical(f"[BB-8] {cmd_func.__name__} failed after {max_attempts} attempts.")
549 |                 publish_bb8_error(f"{cmd_func.__name__} failed after {max_attempts} attempts: {e}")
    |                                                                                         ^^^^^^^^^^^
550 |     return None
    |

E501 Line too long (89 > 88)
   --> bb8_core/ble_bridge.py:559:89
    |
557 |         logger.error(f"[BB-8][ERROR] Failed to publish discovery to MQTT: {e}")
558 |
559 | async def connect_bb8_with_retry(address, max_attempts=5, retry_delay=3, adapter='hci0'):
    |                                                                                         ^
560 |     for attempt in range(1, max_attempts + 1):
561 |         try:
    |

E501 Line too long (89 > 88)
   --> bb8_core/ble_bridge.py:568:89
    |
566 |                     services = await resolve_services(client)
567 |                     if services is None:
568 |                         logger.debug("BLE services not available on this client/version")
    |                                                                                         ^
569 |                         return None
570 |                 found = any(
    |

E501 Line too long (109 > 88)
   --> bb8_core/ble_bridge.py:612:89
    |
610 |             "command_topic": f"{topic_prefix}/command",
611 |             "schema": "json",
612 |             "rgb_command_template": "{{ {'command': 'set_led', 'r': red, 'g': green, 'b': blue} | tojson }}",
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^
613 |             "device": base_device,
614 |         }
    |

E501 Line too long (94 > 88)
   --> bb8_core/ble_bridge.py:678:89
    |
676 |         }
677 |     )
678 | # [2025-08-08 xx:xx] Copilot patch: BLE Watchdog, Core Entity Surfacing, and Dynamic Discovery
    |                                                                                         ^^^^^^
679 | # implemented for enhanced customization of  BB-8 control.
    |

E501 Line too long (97 > 88)
 --> bb8_core/ble_gateway.py:5:89
  |
3 | ble_gateway.py
4 |
5 | Handles BLE adapter selection, device scanning, and connection status for BB-8 device management.
  |                                                                                         ^^^^^^^^^
6 | """
7 | from typing import Optional
  |

I001 [*] Import block is un-sorted or un-formatted
  --> bb8_core/ble_gateway.py:7:1
   |
 5 |   Handles BLE adapter selection, device scanning, and connection status for BB-8 device management.
 6 |   """
 7 | / from typing import Optional
 8 | | from .logging_setup import logger
   | |_________________________________^
 9 |
10 |   try:
   |
help: Organize imports

E501 Line too long (94 > 88)
  --> bb8_core/ble_gateway.py:32:89
   |
30 |         self.adapter = adapter
31 |         self.connected: bool = False
32 |         logger.info({"event": "ble_gateway_init", "mode": self.mode, "adapter": self.adapter})
   |                                                                                         ^^^^^^
33 |         logger.debug({"event": "ble_gateway_init_debug", "mode": self.mode, "adapter": str(self.adapter)})
34 |         logger.debug({"event": "ble_gateway_init_state", "connected": self.connected, "class": str(type(self))})
   |

E501 Line too long (106 > 88)
  --> bb8_core/ble_gateway.py:33:89
   |
31 |         self.connected: bool = False
32 |         logger.info({"event": "ble_gateway_init", "mode": self.mode, "adapter": self.adapter})
33 |         logger.debug({"event": "ble_gateway_init_debug", "mode": self.mode, "adapter": str(self.adapter)})
   |                                                                                         ^^^^^^^^^^^^^^^^^^
34 |         logger.debug({"event": "ble_gateway_init_state", "connected": self.connected, "class": str(type(self))})
   |

E501 Line too long (112 > 88)
  --> bb8_core/ble_gateway.py:34:89
   |
32 |         logger.info({"event": "ble_gateway_init", "mode": self.mode, "adapter": self.adapter})
33 |         logger.debug({"event": "ble_gateway_init_debug", "mode": self.mode, "adapter": str(self.adapter)})
34 |         logger.debug({"event": "ble_gateway_init_state", "connected": self.connected, "class": str(type(self))})
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^
35 |
36 |     def resolve_adapter(self) -> Optional[str]:
   |

E501 Line too long (96 > 88)
  --> bb8_core/ble_gateway.py:43:89
   |
41 |         logger.debug({"event": "ble_scan_start", "mode": self.mode, "seconds": seconds})
42 |         if self.mode != "bleak" or BleakScanner is None:
43 |             logger.debug({"event": "ble_scan_bypass", "reason": "unsupported_or_missing_bleak"})
   |                                                                                         ^^^^^^^^
44 |             return []
45 |         devices = await BleakScanner.discover(timeout=seconds)  # type: ignore[call-arg]
   |

E501 Line too long (116 > 88)
  --> bb8_core/ble_gateway.py:46:89
   |
44 |             return []
45 |         devices = await BleakScanner.discover(timeout=seconds)  # type: ignore[call-arg]
46 |         logger.debug({"event": "ble_scan_devices_found", "devices": [getattr(d, 'address', None) for d in devices]})
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
47 |         result = []
48 |         for d in devices:
   |

E501 Line too long (169 > 88)
  --> bb8_core/ble_gateway.py:49:89
   |
47 | …
48 | …
49 | …name": getattr(d, "name", None), "address": getattr(d, "address", None), "rssi": getattr(d, "rssi", None)})
   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
50 | …address": getattr(d, "address", None), "rssi": getattr(d, "rssi", None)})
51 | …n(result), "devices": result})
   |

E501 Line too long (135 > 88)
  --> bb8_core/ble_gateway.py:50:89
   |
48 | …
49 | …device_detail", "name": getattr(d, "name", None), "address": getattr(d, "address", None), "rssi": getattr(d, "rssi", None)})
50 | … "name", None), "address": getattr(d, "address", None), "rssi": getattr(d, "rssi", None)})
   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
51 | …ete", "count": len(result), "devices": result})
52 | …
   |

E501 Line too long (92 > 88)
  --> bb8_core/ble_gateway.py:51:89
   |
49 | …         logger.debug({"event": "ble_scan_device_detail", "name": getattr(d, "name", None), "address": getattr(d, "address", None), "…
50 | …         result.append({"name": getattr(d, "name", None), "address": getattr(d, "address", None), "rssi": getattr(d, "rssi", None)})
51 | …     logger.info({"event": "ble_scan_complete", "count": len(result), "devices": result})
   |                                                                                       ^^^^
52 | …     return result
   |

E501 Line too long (109 > 88)
  --> bb8_core/ble_gateway.py:56:89
   |
54 |     def get_connection_status(self):
55 |         status = {"connected": getattr(self, 'device', None) is not None}
56 |         logger.debug({"event": "ble_status", "status": status, "device": str(getattr(self, 'device', None))})
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^
57 |         return status
   |

E501 Line too long (109 > 88)
  --> bb8_core/ble_gateway.py:62:89
   |
60 |         logger.info({"event": "ble_gateway_shutdown"})
61 |         try:
62 |             logger.debug({"event": "ble_gateway_shutdown_pre", "device": str(getattr(self, 'device', None))})
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^
63 |             self.device = None
64 |             logger.debug({"event": "ble_gateway_shutdown_device_none"})
   |

E501 Line too long (97 > 88)
  --> bb8_core/ble_gateway.py:66:89
   |
64 |             logger.debug({"event": "ble_gateway_shutdown_device_none"})
65 |         except Exception as e:
66 |             logger.error({"event": "ble_gateway_shutdown_error", "error": str(e)}, exc_info=True)
   |                                                                                         ^^^^^^^^^
   |

I001 [*] Import block is un-sorted or un-formatted
  --> bb8_core/ble_link.py:1:1
   |
 1 | / from __future__ import annotations
 2 | | from typing import TYPE_CHECKING
 3 | | import asyncio
 4 | | from typing import Optional, Callable
 5 | | from .types import (
 6 | |     BoolCallback,
 7 | |     OptIntCallback,
 8 | | )
   | |_^
 9 |   if TYPE_CHECKING:
10 |       from .bridge_controller import BridgeController as _BridgeControllerHint
   |
help: Organize imports

F401 [*] `.types.BoolCallback` imported but unused
 --> bb8_core/ble_link.py:6:5
  |
4 | from typing import Optional, Callable
5 | from .types import (
6 |     BoolCallback,
  |     ^^^^^^^^^^^^
7 |     OptIntCallback,
8 | )
  |
help: Remove unused import

F401 [*] `.types.OptIntCallback` imported but unused
 --> bb8_core/ble_link.py:7:5
  |
5 | from .types import (
6 |     BoolCallback,
7 |     OptIntCallback,
  |     ^^^^^^^^^^^^^^
8 | )
9 | if TYPE_CHECKING:
  |
help: Remove unused import

F401 [*] `.bridge_controller.BridgeController` imported but unused
  --> bb8_core/ble_link.py:10:56
   |
 8 | )
 9 | if TYPE_CHECKING:
10 |     from .bridge_controller import BridgeController as _BridgeControllerHint
   |                                                        ^^^^^^^^^^^^^^^^^^^^^
11 | from bleak import BleakClient, BleakScanner
   |
help: Remove unused import: `.bridge_controller.BridgeController`

I001 [*] Import block is un-sorted or un-formatted
  --> bb8_core/ble_link.py:11:1
   |
 9 | if TYPE_CHECKING:
10 |     from .bridge_controller import BridgeController as _BridgeControllerHint
11 | from bleak import BleakClient, BleakScanner
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
12 |
13 | class BLELink:
   |
help: Organize imports

E501 Line too long (113 > 88)
  --> bb8_core/ble_link.py:14:89
   |
13 | class BLELink:
14 |     def __init__(self, mac: str, on_connected: Callable[[bool], None], on_rssi: Callable[[Optional[int]], None]):
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^
15 |         self.mac, self.on_connected, self.on_rssi = mac, on_connected, on_rssi
16 |         self._stop = False
   |

E401 [*] Multiple imports on one line
  --> bb8_core/ble_link.py:21:9
   |
20 |     def start(self):
21 |         import logging, threading
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^
22 |         log = logging.getLogger(__name__)
23 |         if self._thread: return
   |
help: Split imports

I001 [*] Import block is un-sorted or un-formatted
  --> bb8_core/ble_link.py:21:9
   |
20 |     def start(self):
21 |         import logging, threading
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^
22 |         log = logging.getLogger(__name__)
23 |         if self._thread: return
   |
help: Organize imports

E701 Multiple statements on one line (colon)
  --> bb8_core/ble_link.py:23:24
   |
21 |         import logging, threading
22 |         log = logging.getLogger(__name__)
23 |         if self._thread: return
   |                        ^
24 |         def _runner():
25 |             self._loop = asyncio.new_event_loop()
   |

E702 Multiple statements on one line (semicolon)
  --> bb8_core/ble_link.py:43:30
   |
41 |         import logging
42 |         log = logging.getLogger(__name__)
43 |         backoff = [1,2,5,5,5]; i = 0
   |                              ^
44 |         first_rssi = True
45 |         while not self._stop:
   |

E501 Line too long (107 > 88)
  --> bb8_core/ble_link.py:49:89
   |
47 |                 dev = await BleakScanner.find_device_by_address(self.mac, timeout=5.0)
48 |                 rssi = getattr(dev, "rssi", None) if dev else None
49 |                 log.info({"event": "ble_link_scan_result", "mac": self.mac, "rssi": rssi, "dev": str(dev)})
   |                                                                                         ^^^^^^^^^^^^^^^^^^^
50 |                 self.on_rssi(rssi)
51 |                 if first_rssi:
   |

E501 Line too long (93 > 88)
  --> bb8_core/ble_link.py:52:89
   |
50 |                 self.on_rssi(rssi)
51 |                 if first_rssi:
52 |                     log.info({"event": "ble_link_first_rssi", "mac": self.mac, "rssi": rssi})
   |                                                                                         ^^^^^
53 |                     first_rssi = False
54 |                 if not dev:
   |

E702 Multiple statements on one line (semicolon)
  --> bb8_core/ble_link.py:56:59
   |
54 |                 if not dev:
55 |                     log.info({"event": "ble_link_no_device", "mac": self.mac})
56 |                     await asyncio.sleep(backoff[min(i,4)]); i+=1; continue
   |                                                           ^
57 |                 async with BleakClient(self.mac) as cl:
58 |                     self.on_connected(True); i = 0
   |

E702 Multiple statements on one line (semicolon)
  --> bb8_core/ble_link.py:56:65
   |
54 |                 if not dev:
55 |                     log.info({"event": "ble_link_no_device", "mac": self.mac})
56 |                     await asyncio.sleep(backoff[min(i,4)]); i+=1; continue
   |                                                                 ^
57 |                 async with BleakClient(self.mac) as cl:
58 |                     self.on_connected(True); i = 0
   |

E702 Multiple statements on one line (semicolon)
  --> bb8_core/ble_link.py:58:44
   |
56 |                     await asyncio.sleep(backoff[min(i,4)]); i+=1; continue
57 |                 async with BleakClient(self.mac) as cl:
58 |                     self.on_connected(True); i = 0
   |                                            ^
59 |                     log.info({"event": "ble_link_connected", "mac": self.mac})
60 |                     _ = cl.is_connected
   |

E501 Line too long (94 > 88)
  --> bb8_core/ble_link.py:62:89
   |
60 |                     _ = cl.is_connected
61 |                     while cl.is_connected and not self._stop:
62 |                         dev = await BleakScanner.find_device_by_address(self.mac, timeout=3.0)
   |                                                                                         ^^^^^^
63 |                         rssi = getattr(dev, "rssi", None) if dev else None
64 |                         log.info({"event": "ble_link_poll_rssi", "mac": self.mac, "rssi": rssi, "dev": str(dev)})
   |

E501 Line too long (113 > 88)
  --> bb8_core/ble_link.py:64:89
   |
62 |                         dev = await BleakScanner.find_device_by_address(self.mac, timeout=3.0)
63 |                         rssi = getattr(dev, "rssi", None) if dev else None
64 |                         log.info({"event": "ble_link_poll_rssi", "mac": self.mac, "rssi": rssi, "dev": str(dev)})
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^
65 |                         self.on_rssi(rssi)
66 |                         await asyncio.sleep(5)
   |

E501 Line too long (91 > 88)
  --> bb8_core/ble_link.py:68:89
   |
66 |                         await asyncio.sleep(5)
67 |             except Exception as e:
68 |                 log.warning({"event": "ble_link_error", "mac": self.mac, "error": repr(e)})
   |                                                                                         ^^^
69 |             finally:
70 |                 self.on_connected(False)
   |

E702 Multiple statements on one line (semicolon)
  --> bb8_core/ble_link.py:72:55
   |
70 |                 self.on_connected(False)
71 |                 log.info({"event": "ble_link_disconnected", "mac": self.mac})
72 |                 await asyncio.sleep(backoff[min(i,4)]); i+=1
   |                                                       ^
   |

I001 [*] Import block is un-sorted or un-formatted
 --> bb8_core/ble_utils.py:1:1
  |
1 | / from typing import TYPE_CHECKING
2 | | from typing import Any, Awaitable, Optional
3 | | from .types import (
4 | |     BLELink,
5 | |     BoolCallback,
6 | |     OptIntCallback,
7 | | )
  | |_^
8 |   if TYPE_CHECKING:
9 |       from .bridge_controller import BridgeController as _BridgeControllerHint
  |
help: Organize imports

F401 [*] `typing.Awaitable` imported but unused
 --> bb8_core/ble_utils.py:2:25
  |
1 | from typing import TYPE_CHECKING
2 | from typing import Any, Awaitable, Optional
  |                         ^^^^^^^^^
3 | from .types import (
4 |     BLELink,
  |
help: Remove unused import: `typing.Awaitable`

F401 [*] `.types.BLELink` imported but unused
 --> bb8_core/ble_utils.py:4:5
  |
2 | from typing import Any, Awaitable, Optional
3 | from .types import (
4 |     BLELink,
  |     ^^^^^^^
5 |     BoolCallback,
6 |     OptIntCallback,
  |
help: Remove unused import

F401 [*] `.types.BoolCallback` imported but unused
 --> bb8_core/ble_utils.py:5:5
  |
3 | from .types import (
4 |     BLELink,
5 |     BoolCallback,
  |     ^^^^^^^^^^^^
6 |     OptIntCallback,
7 | )
  |
help: Remove unused import

F401 [*] `.types.OptIntCallback` imported but unused
 --> bb8_core/ble_utils.py:6:5
  |
4 |     BLELink,
5 |     BoolCallback,
6 |     OptIntCallback,
  |     ^^^^^^^^^^^^^^
7 | )
8 | if TYPE_CHECKING:
  |
help: Remove unused import

F401 [*] `.bridge_controller.BridgeController` imported but unused
  --> bb8_core/ble_utils.py:9:56
   |
 7 | )
 8 | if TYPE_CHECKING:
 9 |     from .bridge_controller import BridgeController as _BridgeControllerHint
   |                                                        ^^^^^^^^^^^^^^^^^^^^^
10 | import inspect
   |
help: Remove unused import: `.bridge_controller.BridgeController`

I001 [*] Import block is un-sorted or un-formatted
  --> bb8_core/ble_utils.py:10:1
   |
 8 | if TYPE_CHECKING:
 9 |     from .bridge_controller import BridgeController as _BridgeControllerHint
10 | import inspect
   | ^^^^^^^^^^^^^^
11 |
12 | async def resolve_services(client: Any) -> Optional[Any]:
   |
help: Organize imports

I001 [*] Import block is un-sorted or un-formatted
  --> bb8_core/bridge_controller.py:12:1
   |
10 |   All code lives inside functions; only the __main__ guard executes main().
11 |   """
12 | / from __future__ import annotations
13 | | from typing import TYPE_CHECKING
14 | | from typing import Optional, Tuple, Dict, Any
15 | | from .types import (
16 | |     BridgeController,
17 | |     BLELink,
18 | |     MqttClient,
19 | |     BoolCallback,
20 | |     IntCallback,
21 | |     OptIntCallback,
22 | |     RGBCallback,
23 | | )
   | |_^
24 |   if TYPE_CHECKING:
25 |       from .bridge_controller import BridgeController as _BridgeControllerHint
   |
help: Organize imports

F401 [*] `typing.Tuple` imported but unused
  --> bb8_core/bridge_controller.py:14:30
   |
12 | from __future__ import annotations
13 | from typing import TYPE_CHECKING
14 | from typing import Optional, Tuple, Dict, Any
   |                              ^^^^^
15 | from .types import (
16 |     BridgeController,
   |
help: Remove unused import: `typing.Tuple`

F401 [*] `.types.BridgeController` imported but unused
  --> bb8_core/bridge_controller.py:16:5
   |
14 | from typing import Optional, Tuple, Dict, Any
15 | from .types import (
16 |     BridgeController,
   |     ^^^^^^^^^^^^^^^^
17 |     BLELink,
18 |     MqttClient,
   |
help: Remove unused import

F401 [*] `.types.MqttClient` imported but unused
  --> bb8_core/bridge_controller.py:18:5
   |
16 |     BridgeController,
17 |     BLELink,
18 |     MqttClient,
   |     ^^^^^^^^^^
19 |     BoolCallback,
20 |     IntCallback,
   |
help: Remove unused import

F401 [*] `.types.BoolCallback` imported but unused
  --> bb8_core/bridge_controller.py:19:5
   |
17 |     BLELink,
18 |     MqttClient,
19 |     BoolCallback,
   |     ^^^^^^^^^^^^
20 |     IntCallback,
21 |     OptIntCallback,
   |
help: Remove unused import

F401 [*] `.types.IntCallback` imported but unused
  --> bb8_core/bridge_controller.py:20:5
   |
18 |     MqttClient,
19 |     BoolCallback,
20 |     IntCallback,
   |     ^^^^^^^^^^^
21 |     OptIntCallback,
22 |     RGBCallback,
   |
help: Remove unused import

F401 [*] `.types.OptIntCallback` imported but unused
  --> bb8_core/bridge_controller.py:21:5
   |
19 |     BoolCallback,
20 |     IntCallback,
21 |     OptIntCallback,
   |     ^^^^^^^^^^^^^^
22 |     RGBCallback,
23 | )
   |
help: Remove unused import

F401 [*] `.types.RGBCallback` imported but unused
  --> bb8_core/bridge_controller.py:22:5
   |
20 |     IntCallback,
21 |     OptIntCallback,
22 |     RGBCallback,
   |     ^^^^^^^^^^^
23 | )
24 | if TYPE_CHECKING:
   |
help: Remove unused import

F401 [*] `.bridge_controller.BridgeController` imported but unused
  --> bb8_core/bridge_controller.py:25:56
   |
23 | )
24 | if TYPE_CHECKING:
25 |     from .bridge_controller import BridgeController as _BridgeControllerHint
   |                                                        ^^^^^^^^^^^^^^^^^^^^^
26 | import signal
27 | import time
   |
help: Remove unused import: `.bridge_controller.BridgeController`

I001 [*] Import block is un-sorted or un-formatted
  --> bb8_core/bridge_controller.py:26:1
   |
24 |   if TYPE_CHECKING:
25 |       from .bridge_controller import BridgeController as _BridgeControllerHint
26 | / import signal
27 | | import time
28 | | import threading
29 | | import json
30 | | import logging
31 | |
32 | | from .addon_config import load_config
33 | |
34 | | # Internal imports
35 | | from .version_probe import probe
36 | | from .logging_setup import logger
37 | | from .auto_detect import resolve_bb8_mac
38 | | from .ble_gateway import BleGateway
39 | | from .ble_bridge import BLEBridge
40 | |
41 | | from .common import publish_device_echo, TOPICS
42 | | from .facade import BB8Facade
43 | | from .mqtt_dispatcher import start_mqtt_dispatcher
44 | | from .ble_link import BLELink
45 | | import threading, asyncio
46 | | from .evidence_capture import EvidenceRecorder
   | |______________________________________________^
   |
help: Organize imports

F811 Redefinition of unused `BLELink` from line 17
  --> bb8_core/bridge_controller.py:44:23
   |
42 | from .facade import BB8Facade
43 | from .mqtt_dispatcher import start_mqtt_dispatcher
44 | from .ble_link import BLELink
   |                       ^^^^^^^
45 | import threading, asyncio
46 | from .evidence_capture import EvidenceRecorder
   |
help: Remove definition: `BLELink`

E401 [*] Multiple imports on one line
  --> bb8_core/bridge_controller.py:45:1
   |
43 | from .mqtt_dispatcher import start_mqtt_dispatcher
44 | from .ble_link import BLELink
45 | import threading, asyncio
   | ^^^^^^^^^^^^^^^^^^^^^^^^^
46 | from .evidence_capture import EvidenceRecorder
   |
help: Split imports

F811 [*] Redefinition of unused `threading` from line 28
  --> bb8_core/bridge_controller.py:45:8
   |
43 | from .mqtt_dispatcher import start_mqtt_dispatcher
44 | from .ble_link import BLELink
45 | import threading, asyncio
   |        ^^^^^^^^^
46 | from .evidence_capture import EvidenceRecorder
   |
help: Remove definition: `threading`

E501 Line too long (92 > 88)
  --> bb8_core/bridge_controller.py:66:89
   |
64 |     Start MQTT dispatcher, pruning/aliasing kwargs to match the function signature.
65 |     Supports both legacy ('host','port','topic','user','password','controller')
66 |     and new-style ('mqtt_host','mqtt_port','mqtt_topic','username','passwd','bridge') names.
   |                                                                                         ^^^^
67 |     """
68 |     import inspect
   |

E501 Line too long (91 > 88)
   --> bb8_core/bridge_controller.py:160:89
    |
158 |     import os
159 |     """
160 |     Bring up BLE gateway + bridge, resolve target MAC if needed, and start MQTT dispatcher.
    |                                                                                         ^^^
161 |     """
162 |     logger.info({
    |

E501 Line too long (98 > 88)
   --> bb8_core/bridge_controller.py:172:89
    |
170 |     # Initialize BLE gateway
171 |     gw = BleGateway(mode="bleak", adapter=cfg.get("ble_adapter"))
172 |     logger.info({"event": "ble_gateway_init", "mode": gw.mode, "adapter": cfg.get("ble_adapter")})
    |                                                                                         ^^^^^^^^^^
173 |
174 |     # Resolve BB-8 MAC if not provided
    |

E501 Line too long (107 > 88)
   --> bb8_core/bridge_controller.py:192:89
    |
190 |         logger.info({"event": "bb8_mac_resolve_success", "bb8_mac": target_mac})
191 |     else:
192 |         logger.info({"event": "bb8_mac_resolve_bypass", "reason": "env_or_options", "bb8_mac": target_mac})
    |                                                                                         ^^^^^^^^^^^^^^^^^^^
193 |
194 |     # Construct bridge and facade
    |

E501 Line too long (93 > 88)
   --> bb8_core/bridge_controller.py:195:89
    |
194 |     # Construct bridge and facade
195 |     bridge = BLEBridge(gateway=gw, target_mac=target_mac, ble_adapter=cfg.get("ble_adapter"))
    |                                                                                         ^^^^^
196 |     logger.info({"event": "ble_bridge_init", "target_mac": target_mac})
197 |     facade = BB8Facade(bridge)
    |

E501 Line too long (121 > 88)
   --> bb8_core/bridge_controller.py:281:89
    |
279 |     # Start evidence recorder (subscriber-only, unified config)
280 |     # Provenance-aware config loading
281 |     enable_evidence, src_enable = cfg.get("enable_stp4_evidence", True), cfg.get("_prov_enable_stp4_evidence", "default")
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
282 |     report_path, src_report = cfg.get("evidence_report_path", "/app/reports/ha_mqtt_trace_snapshot.jsonl"), cfg.get("_prov_evidence_r…
283 |     topic_prefix, src_topic = cfg.get("mqtt_topic", "bb8"), cfg.get("_prov_mqtt_topic", "default")
    |

E501 Line too long (156 > 88)
   --> bb8_core/bridge_controller.py:282:89
    |
280 | …
281 | …vidence", True), cfg.get("_prov_enable_stp4_evidence", "default")
282 | …ath", "/app/reports/ha_mqtt_trace_snapshot.jsonl"), cfg.get("_prov_evidence_report_path", "default")
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
283 | …"), cfg.get("_prov_mqtt_topic", "default")
284 | …
    |

E501 Line too long (98 > 88)
   --> bb8_core/bridge_controller.py:283:89
    |
281 |     enable_evidence, src_enable = cfg.get("enable_stp4_evidence", True), cfg.get("_prov_enable_stp4_evidence", "default")
282 |     report_path, src_report = cfg.get("evidence_report_path", "/app/reports/ha_mqtt_trace_snapshot.jsonl"), cfg.get("_prov_evidence_r…
283 |     topic_prefix, src_topic = cfg.get("mqtt_topic", "bb8"), cfg.get("_prov_mqtt_topic", "default")
    |                                                                                         ^^^^^^^^^^
284 |     if enable_evidence:
285 |         try:
    |

E501 Line too long (105 > 88)
   --> bb8_core/bridge_controller.py:313:89
    |
311 |         try:
312 |             from .telemetry import Telemetry
313 |             logger.info({"event": "telemetry_start", "interval_s": telemetry_interval, "role": "bridge"})
    |                                                                                         ^^^^^^^^^^^^^^^^^
314 |             telemetry = Telemetry(bridge)
315 |             telemetry.start()
    |

E501 Line too long (112 > 88)
   --> bb8_core/bridge_controller.py:316:89
    |
314 |             telemetry = Telemetry(bridge)
315 |             telemetry.start()
316 |             logger.info({"event": "telemetry_loop_started", "interval_s": telemetry_interval, "role": "bridge"})
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^
317 |         except Exception as e:
318 |             logger.warning({"event": "telemetry_error", "error": repr(e), "role": "bridge"})
    |

E501 Line too long (92 > 88)
   --> bb8_core/bridge_controller.py:318:89
    |
316 |             logger.info({"event": "telemetry_loop_started", "interval_s": telemetry_interval, "role": "bridge"})
317 |         except Exception as e:
318 |             logger.warning({"event": "telemetry_error", "error": repr(e), "role": "bridge"})
    |                                                                                         ^^^^
319 |     else:
320 |         logger.info({"event": "telemetry_skipped", "reason": "scanner_owns_telemetry", "role": "bridge"})
    |

E501 Line too long (105 > 88)
   --> bb8_core/bridge_controller.py:320:89
    |
318 |             logger.warning({"event": "telemetry_error", "error": repr(e), "role": "bridge"})
319 |     else:
320 |         logger.info({"event": "telemetry_skipped", "reason": "scanner_owns_telemetry", "role": "bridge"})
    |                                                                                         ^^^^^^^^^^^^^^^^^
321 |
322 |     # Register quick-echo handler for power/set topic inside the running controller
    |

N806 Variable `REQUIRE_DEVICE_ECHO` in function should be lowercase
   --> bb8_core/bridge_controller.py:324:5
    |
322 |     # Register quick-echo handler for power/set topic inside the running controller
323 |     import os
324 |     REQUIRE_DEVICE_ECHO = os.environ.get("REQUIRE_DEVICE_ECHO", "1") not in ("0", "false", "no", "off")
    |     ^^^^^^^^^^^^^^^^^^^
325 |     # Device echo handlers
326 |     def on_power_set(payload):
    |

F841 Local variable `REQUIRE_DEVICE_ECHO` is assigned to but never used
   --> bb8_core/bridge_controller.py:324:5
    |
322 |     # Register quick-echo handler for power/set topic inside the running controller
323 |     import os
324 |     REQUIRE_DEVICE_ECHO = os.environ.get("REQUIRE_DEVICE_ECHO", "1") not in ("0", "false", "no", "off")
    |     ^^^^^^^^^^^^^^^^^^^
325 |     # Device echo handlers
326 |     def on_power_set(payload):
    |
help: Remove assignment to unused variable `REQUIRE_DEVICE_ECHO`

E501 Line too long (103 > 88)
   --> bb8_core/bridge_controller.py:324:89
    |
322 |     # Register quick-echo handler for power/set topic inside the running controller
323 |     import os
324 |     REQUIRE_DEVICE_ECHO = os.environ.get("REQUIRE_DEVICE_ECHO", "1") not in ("0", "false", "no", "off")
    |                                                                                         ^^^^^^^^^^^^^^^
325 |     # Device echo handlers
326 |     def on_power_set(payload):
    |

N806 Variable `CFG` in function should be lowercase
   --> bb8_core/bridge_controller.py:355:5
    |
353 |     # Single, final version probe (no preface “missing” lines)
354 |     logging.getLogger("bb8_addon").info(probe())
355 |     CFG, SRC = load_config()
    |     ^^^
356 |     cfg = CFG
357 |     # Emit one-shot INFO banner of all active config keys and their sources
    |

N806 Variable `SRC` in function should be lowercase
   --> bb8_core/bridge_controller.py:355:10
    |
353 |     # Single, final version probe (no preface “missing” lines)
354 |     logging.getLogger("bb8_addon").info(probe())
355 |     CFG, SRC = load_config()
    |          ^^^
356 |     cfg = CFG
357 |     # Emit one-shot INFO banner of all active config keys and their sources
    |

I001 [*] Import block is un-sorted or un-formatted
 --> bb8_core/common.py:1:1
  |
1 | import json
  | ^^^^^^^^^^^
2 |
3 | def publish_device_echo(client, topic, value):
  |
help: Organize imports

E402 Module level import not at top of file
  --> bb8_core/common.py:21:1
   |
20 | # File: bb8_core/bridge_controller.py (wires device-echo handlers, LED, BLE)
21 | from bb8_core.common import publish_device_echo, TOPICS
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
22 |
23 | # Replace publish with helper in handlers:
   |

I001 [*] Import block is un-sorted or un-formatted
  --> bb8_core/common.py:21:1
   |
20 | # File: bb8_core/bridge_controller.py (wires device-echo handlers, LED, BLE)
21 | from bb8_core.common import publish_device_echo, TOPICS
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
22 |
23 | # Replace publish with helper in handlers:
   |
help: Organize imports

F811 Redefinition of unused `publish_device_echo` from line 3
  --> bb8_core/common.py:21:29
   |
20 | # File: bb8_core/bridge_controller.py (wires device-echo handlers, LED, BLE)
21 | from bb8_core.common import publish_device_echo, TOPICS
   |                             ^^^^^^^^^^^^^^^^^^^
22 |
23 | # Replace publish with helper in handlers:
   |
help: Remove definition: `publish_device_echo`

F811 Redefinition of unused `TOPICS` from line 9
  --> bb8_core/common.py:21:50
   |
20 | # File: bb8_core/bridge_controller.py (wires device-echo handlers, LED, BLE)
21 | from bb8_core.common import publish_device_echo, TOPICS
   |                                                  ^^^^^^
22 |
23 | # Replace publish with helper in handlers:
   |
help: Remove definition: `TOPICS`

F821 Undefined name `client`
  --> bb8_core/common.py:25:25
   |
23 | # Replace publish with helper in handlers:
24 | def on_power_set(payload):
25 |     publish_device_echo(client, TOPICS["power"], payload)
   |                         ^^^^^^
26 |
27 | def on_stop():
   |

F821 Undefined name `client`
  --> bb8_core/common.py:28:25
   |
27 | def on_stop():
28 |     publish_device_echo(client, TOPICS["stop"], "pressed")
   |                         ^^^^^^
29 |
30 | def on_sleep():
   |

F821 Undefined name `client`
  --> bb8_core/common.py:31:25
   |
30 | def on_sleep():
31 |     publish_device_echo(client, TOPICS["sleep"], "idle")
   |                         ^^^^^^
32 |
33 | def on_drive(value):
   |

F821 Undefined name `client`
  --> bb8_core/common.py:34:25
   |
33 | def on_drive(value):
34 |     publish_device_echo(client, TOPICS["drive"], value)
   |                         ^^^^^^
35 |
36 | def on_heading(value):
   |

F821 Undefined name `client`
  --> bb8_core/common.py:37:25
   |
36 | def on_heading(value):
37 |     publish_device_echo(client, TOPICS["heading"], value)
   |                         ^^^^^^
38 |
39 | def on_speed(value):
   |

F821 Undefined name `client`
  --> bb8_core/common.py:40:25
   |
39 | def on_speed(value):
40 |     publish_device_echo(client, TOPICS["speed"], value)
   |                         ^^^^^^
41 |
42 | def on_led_set(r, g, b):
   |

F821 Undefined name `client`
  --> bb8_core/common.py:44:5
   |
42 | def on_led_set(r, g, b):
43 |     payload = json.dumps({"r": r, "g": g, "b": b})
44 |     client.publish(TOPICS["led"], payload=payload, qos=1, retain=False)
   |     ^^^^^^
45 |
46 | # BLE loop thread setup
   |

E401 [*] Multiple imports on one line
  --> bb8_core/common.py:47:1
   |
46 | # BLE loop thread setup
47 | import threading, asyncio
   | ^^^^^^^^^^^^^^^^^^^^^^^^^
48 |
49 | ble_loop = asyncio.new_event_loop()
   |
help: Split imports

E402 Module level import not at top of file
  --> bb8_core/common.py:47:1
   |
46 | # BLE loop thread setup
47 | import threading, asyncio
   | ^^^^^^^^^^^^^^^^^^^^^^^^^
48 |
49 | ble_loop = asyncio.new_event_loop()
   |

I001 [*] Import block is un-sorted or un-formatted
  --> bb8_core/common.py:47:1
   |
46 | # BLE loop thread setup
47 | import threading, asyncio
   | ^^^^^^^^^^^^^^^^^^^^^^^^^
48 |
49 | ble_loop = asyncio.new_event_loop()
   |
help: Organize imports

E402 Module level import not at top of file
  --> bb8_core/common.py:58:1
   |
56 | # File: bb8_core/facade.py and bb8_core/ble_link.py
57 | # Remove circular imports; import constants via common
58 | from bb8_core.common import TOPICS
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |

I001 [*] Import block is un-sorted or un-formatted
  --> bb8_core/common.py:58:1
   |
56 | # File: bb8_core/facade.py and bb8_core/ble_link.py
57 | # Remove circular imports; import constants via common
58 | from bb8_core.common import TOPICS
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: Organize imports

F811 [*] Redefinition of unused `TOPICS` from line 21
  --> bb8_core/common.py:58:29
   |
56 | # File: bb8_core/facade.py and bb8_core/ble_link.py
57 | # Remove circular imports; import constants via common
58 | from bb8_core.common import TOPICS
   |                             ^^^^^^
   |
help: Remove definition: `TOPICS`

F821 Undefined name `dispatcher`
  --> bb8_core/common.py:63:8
   |
61 | # File: bb8_core/bb8_presence_scanner.py
62 | # Guard dispatcher init to ensure scanner is the source
63 | if not dispatcher.is_initialized():
   |        ^^^^^^^^^^
64 |     dispatcher.init("bb8")  # enforce single discovery source
   |

F821 Undefined name `dispatcher`
  --> bb8_core/common.py:64:5
   |
62 | # Guard dispatcher init to ensure scanner is the source
63 | if not dispatcher.is_initialized():
64 |     dispatcher.init("bb8")  # enforce single discovery source
   |     ^^^^^^^^^^
   |

E501 Line too long (161 > 88)
 --> bb8_core/controller.py:4:89
  |
2 | …
3 | …
4 | …tegration with Home Assistant, including BLE device management, command dispatch, and MQTT diagnostics.
  |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
5 | …
6 | …
  |

I001 [*] Import block is un-sorted or un-formatted
  --> bb8_core/controller.py:18:1
   |
16 |   >>> ctrl.stop()
17 |   """
18 | / import time
19 | | from enum import Enum
20 | | from dataclasses import dataclass
21 | | from typing import Optional, Dict, Any
22 | | from .ble_gateway import BleGateway
23 | | from .logging_setup import logger
   | |_________________________________^
24 |
25 |   class ControllerMode(Enum):
   |
help: Organize imports

F401 [*] `.ble_gateway.BleGateway` imported but unused
  --> bb8_core/controller.py:22:26
   |
20 | from dataclasses import dataclass
21 | from typing import Optional, Dict, Any
22 | from .ble_gateway import BleGateway
   |                          ^^^^^^^^^^
23 | from .logging_setup import logger
   |
help: Remove unused import: `.ble_gateway.BleGateway`

E501 Line too long (103 > 88)
  --> bb8_core/controller.py:41:89
   |
40 | class BB8Controller:
41 |     def __init__(self, mode: ControllerMode = ControllerMode.HARDWARE, device=None, mqtt_handler=None):
   |                                                                                         ^^^^^^^^^^^^^^^
42 |         """
43 |         Initialize a BB8Controller instance.
   |

E501 Line too long (149 > 88)
  --> bb8_core/controller.py:67:89
   |
65 | …
66 | …
67 | …g", "mode": self.mode.value, "device": str(self.device), "mqtt_handler": str(self.mqtt_handler)})
   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
68 | …e", "device_connected": self.device_connected, "class": str(type(self))})
   |

E501 Line too long (125 > 88)
  --> bb8_core/controller.py:68:89
   |
66 |         self.telemetry = None
67 |         logger.debug({"event": "controller_init_debug", "mode": self.mode.value, "device": str(self.device), "mqtt_handler": str(self.…
68 |         logger.debug({"event": "controller_init_state", "device_connected": self.device_connected, "class": str(type(self))})
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
69 |
70 |     def roll(self, speed: int, heading: int, timeout: float = 2.0, roll_mode: int = 0, reverse_flag: bool = False) -> dict:
   |

E501 Line too long (123 > 88)
  --> bb8_core/controller.py:70:89
   |
68 |         logger.debug({"event": "controller_init_state", "device_connected": self.device_connected, "class": str(type(self))})
69 |
70 |     def roll(self, speed: int, heading: int, timeout: float = 2.0, roll_mode: int = 0, reverse_flag: bool = False) -> dict:
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
71 |         """
72 |         Roll the BB-8 device at a given speed and heading.
   |

E501 Line too long (165 > 88)
  --> bb8_core/controller.py:93:89
   |
91 | …
92 | …ce": str(self.device)})
93 | …d": speed, "heading": heading, "timeout": timeout, "roll_mode": roll_mode, "reverse_flag": reverse_flag})
   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
94 | …
95 | …ice"})
   |

E501 Line too long (167 > 88)
   --> bb8_core/controller.py:99:89
    |
 97 | …
 98 | …
 99 | …d": speed, "heading": heading, "timeout": timeout, "roll_mode": roll_mode, "reverse_flag": reverse_flag})
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
100 | …
101 | …ck", "hasattr": hasattr(self.device, "roll"), "callable": callable(getattr(self.device, "roll", None))})
    |

E501 Line too long (166 > 88)
   --> bb8_core/controller.py:101:89
    |
 99 | …ed": speed, "heading": heading, "timeout": timeout, "roll_mode": roll_mode, "reverse_flag": reverse_flag})
100 | …
101 | …eck", "hasattr": hasattr(self.device, "roll"), "callable": callable(getattr(self.device, "roll", None))})
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
102 | ….device.roll):
103 | …g=heading, timeout=timeout)
    |

E501 Line too long (123 > 88)
   --> bb8_core/controller.py:105:89
    |
103 |                 result = self.device.roll(speed=speed, heading=heading, timeout=timeout)
104 |                 logger.info({"event": "controller_roll_result", "result": result})
105 |                 logger.debug({"event": "controller_roll_result_debug", "result_type": str(type(result)), "result": result})
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
106 |                 # Publish echo
107 |                 from .mqtt_echo import echo_scalar
    |

E501 Line too long (103 > 88)
   --> bb8_core/controller.py:109:89
    |
107 |                 from .mqtt_echo import echo_scalar
108 |                 if hasattr(self, "mqtt_handler") and self.mqtt_handler:
109 |                     echo_scalar(self.mqtt_handler, "bb8", "roll", {"speed": speed, "heading": heading})
    |                                                                                         ^^^^^^^^^^^^^^^
110 |                 return result if isinstance(result, dict) else {"success": result is None, "command": "roll", "result": result}
111 |             else:
    |

E501 Line too long (127 > 88)
   --> bb8_core/controller.py:110:89
    |
108 |                 if hasattr(self, "mqtt_handler") and self.mqtt_handler:
109 |                     echo_scalar(self.mqtt_handler, "bb8", "roll", {"speed": speed, "heading": heading})
110 |                 return result if isinstance(result, dict) else {"success": result is None, "command": "roll", "result": result}
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
111 |             else:
112 |                 logger.warning({"event": "controller_roll_not_supported"})
    |

E501 Line too long (92 > 88)
   --> bb8_core/controller.py:116:89
    |
114 |         except Exception as e:
115 |             self.error_count += 1
116 |             logger.error({"event": "controller_roll_error", "error": str(e)}, exc_info=True)
    |                                                                                         ^^^^
117 |             return self._create_error_result("roll", str(e))
    |

E501 Line too long (166 > 88)
   --> bb8_core/controller.py:137:89
    |
135 | …
136 | …
137 | …eck", "hasattr": hasattr(self.device, "stop"), "callable": callable(getattr(self.device, "stop", None))})
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
138 | ….device.stop):
139 | …
    |

E501 Line too long (123 > 88)
   --> bb8_core/controller.py:141:89
    |
139 |                 result = self.device.stop()
140 |                 logger.info({"event": "controller_stop_result", "result": result})
141 |                 logger.debug({"event": "controller_stop_result_debug", "result_type": str(type(result)), "result": result})
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
142 |                 # Publish echo
143 |                 from .mqtt_echo import echo_scalar
    |

E501 Line too long (105 > 88)
   --> bb8_core/controller.py:146:89
    |
144 |                 if hasattr(self, "mqtt_handler") and self.mqtt_handler:
145 |                     echo_scalar(self.mqtt_handler, "bb8", "stop", True)
146 |                 return {"success": result is True or result is None, "command": "stop", "result": result}
    |                                                                                         ^^^^^^^^^^^^^^^^^
147 |             else:
148 |                 logger.warning({"event": "controller_stop_not_supported"})
    |

E501 Line too long (92 > 88)
   --> bb8_core/controller.py:152:89
    |
150 |         except Exception as e:
151 |             self.error_count += 1
152 |             logger.error({"event": "controller_stop_error", "error": str(e)}, exc_info=True)
    |                                                                                         ^^^^
153 |             return self._create_error_result("stop", str(e))
    |

E501 Line too long (110 > 88)
   --> bb8_core/controller.py:173:89
    |
171 |             Result dictionary with success, command, and result/error fields.
172 |         """
173 |         logger.debug({"event": "controller_set_led_args", "r": r, "g": g, "b": b, "device": str(self.device)})
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^
174 |         try:
175 |             if self.device is None:
    |

E501 Line too long (93 > 88)
   --> bb8_core/controller.py:177:89
    |
175 | …     if self.device is None:
176 | …         logger.warning({"event": "controller_set_led_no_device"})
177 | …         return {"success": False, "command": "set_led", "error": "No device present"}
    |                                                                                   ^^^^^
178 | …     logger.debug({"event": "controller_set_led_device_check", "hasattr": hasattr(self.device, "set_led"), "callable": callable(geta…
179 | …     if hasattr(self.device, "set_led") and callable(self.device.set_led):
    |

E501 Line too long (175 > 88)
   --> bb8_core/controller.py:178:89
    |
176 | …vice"})
177 | …rror": "No device present"}
178 | …k", "hasattr": hasattr(self.device, "set_led"), "callable": callable(getattr(self.device, "set_led", None))})
    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
179 | …evice.set_led):
180 | …
    |

E501 Line too long (126 > 88)
   --> bb8_core/controller.py:182:89
    |
180 |                 result = self.device.set_led(r, g, b)
181 |                 logger.info({"event": "controller_set_led_result", "result": result})
182 |                 logger.debug({"event": "controller_set_led_result_debug", "result_type": str(type(result)), "result": result})
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
183 |                 # Publish echo
184 |                 from .mqtt_echo import echo_led
    |

E501 Line too long (130 > 88)
   --> bb8_core/controller.py:187:89
    |
185 |                 if hasattr(self, "mqtt_handler") and self.mqtt_handler:
186 |                     echo_led(self.mqtt_handler, "bb8", r, g, b)
187 |                 return result if isinstance(result, dict) else {"success": result is None, "command": "set_led", "result": result}
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
188 |             else:
189 |                 logger.warning({"event": "controller_set_led_not_supported"})
    |

E501 Line too long (104 > 88)
   --> bb8_core/controller.py:190:89
    |
188 |             else:
189 |                 logger.warning({"event": "controller_set_led_not_supported"})
190 |                 return {"success": False, "command": "set_led", "error": "Not supported by this device"}
    |                                                                                         ^^^^^^^^^^^^^^^^
191 |         except Exception as e:
192 |             logger.warning({"event": "controller_set_led_error", "error": str(e)}, exc_info=True)
    |

E501 Line too long (97 > 88)
   --> bb8_core/controller.py:192:89
    |
190 |                 return {"success": False, "command": "set_led", "error": "Not supported by this device"}
191 |         except Exception as e:
192 |             logger.warning({"event": "controller_set_led_error", "error": str(e)}, exc_info=True)
    |                                                                                         ^^^^^^^^^
193 |             return {"success": False, "command": "set_led", "error": str(e)}
    |

E501 Line too long (94 > 88)
   --> bb8_core/controller.py:283:89
    |
281 |             Error result dictionary.
282 |         """
283 |         logger.error({"event": "controller_error_result", "command": command, "error": error})
    |                                                                                         ^^^^^^
284 |         return {
285 |             "success": False,
    |

E501 Line too long (136 > 88)
   --> bb8_core/controller.py:306:89
    |
304 | …None
305 | …ch_device", "device": str(device)})
306 | …ach_device_debug", "device": str(self.device), "device_connected": self.device_connected})
    |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
307 | …ct
308 | …
    |

I001 [*] Import block is un-sorted or un-formatted
 --> bb8_core/core.py:1:1
  |
1 | / from __future__ import annotations
2 | | from typing import Optional
3 | | from .logging_setup import logger
  | |_________________________________^
4 |
5 |   class Core:
  |
help: Organize imports

E501 Line too long (95 > 88)
  --> bb8_core/core.py:23:89
   |
22 |     def __exit__(self, exc_type, exc, tb) -> None:
23 |         logger.info({"event": "core_exit", "address": self.address, "exc_type": str(exc_type)})
   |                                                                                         ^^^^^^^
24 |         self.disconnect()
   |

E501 Line too long (91 > 88)
  --> bb8_core/core.py:38:89
   |
36 |         logger.info({"event": "core_disconnected", "address": self.address})
37 |
38 |     def set_main_led(self, r: int, g: int, b: int, persist: Optional[bool] = None) -> None:
   |                                                                                         ^^^
39 |         logger.info({"event": "core_set_main_led", "address": self.address, "r": r, "g": g, "b": b, "persist": persist})
40 |         # TODO: send LED command over BLE
   |

E501 Line too long (120 > 88)
  --> bb8_core/core.py:39:89
   |
38 |     def set_main_led(self, r: int, g: int, b: int, persist: Optional[bool] = None) -> None:
39 |         logger.info({"event": "core_set_main_led", "address": self.address, "r": r, "g": g, "b": b, "persist": persist})
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
40 |         # TODO: send LED command over BLE
41 |         ...
   |

E501 Line too long (132 > 88)
  --> bb8_core/core.py:44:89
   |
43 |     def roll(self, speed: int, heading: int, duration_ms: int) -> None:
44 |         logger.info({"event": "core_roll", "address": self.address, "speed": speed, "heading": heading, "duration_ms": duration_ms})
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
45 |         # TODO: send roll/drive
46 |         ...
   |

E501 Line too long (140 > 88)
  --> bb8_core/core.py:49:89
   |
48 | …: int, p3: int) -> None:
49 | …ress": self.address, "interval_option": str(interval_option), "p1": p1, "p2": p2, "p3": p3})
   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
50 | …
51 | …
   |

I001 [*] Import block is un-sorted or un-formatted
 --> bb8_core/evidence_capture.py:1:1
  |
1 | / from __future__ import annotations
2 | | import json, time, threading, queue, os
3 | | from typing import Any, Dict, Optional
  | |______________________________________^
4 |
5 |   class EvidenceRecorder:
  |
help: Organize imports

E401 [*] Multiple imports on one line
 --> bb8_core/evidence_capture.py:2:1
  |
1 | from __future__ import annotations
2 | import json, time, threading, queue, os
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
3 | from typing import Any, Dict, Optional
  |
help: Split imports

E701 Multiple statements on one line (colon)
  --> bb8_core/evidence_capture.py:25:42
   |
24 |     def start(self):
25 |         if self._t and self._t.is_alive(): return
   |                                          ^
26 |         self._stop.clear()
27 |         self._install_callbacks()
   |

E501 Line too long (90 > 88)
  --> bb8_core/evidence_capture.py:28:89
   |
26 |         self._stop.clear()
27 |         self._install_callbacks()
28 |         self._t = threading.Thread(target=self._runner, name="stp4_evidence", daemon=True)
   |                                                                                         ^^
29 |         self._t.start()
   |

E701 Multiple statements on one line (colon)
  --> bb8_core/evidence_capture.py:33:19
   |
31 |     def stop(self):
32 |         self._stop.set()
33 |         if self._t: self._t.join(timeout=1.0)
   |                   ^
34 |
35 |     def _install_callbacks(self):
   |

E701 Multiple statements on one line (colon)
  --> bb8_core/evidence_capture.py:43:16
   |
41 |         def on_message(_c, _u, msg):
42 |             now = time.time()
43 |             try: payload = msg.payload.decode("utf-8", "ignore")
   |                ^
44 |             except Exception: payload = "<binary>"
45 |             evt = {"ts": now, "topic": msg.topic, "payload": payload}
   |

E701 Multiple statements on one line (colon)
  --> bb8_core/evidence_capture.py:44:29
   |
42 |             now = time.time()
43 |             try: payload = msg.payload.decode("utf-8", "ignore")
44 |             except Exception: payload = "<binary>"
   |                             ^
45 |             evt = {"ts": now, "topic": msg.topic, "payload": payload}
46 |             (self._cmd_q if "/cmd/" in msg.topic else self._evt_q).put(evt)
   |

E701 Multiple statements on one line (colon)
  --> bb8_core/evidence_capture.py:51:20
   |
49 |         def chained(client, userdata, msg):
50 |             if callable(old):
51 |                 try: old(client, userdata, msg)
   |                    ^
52 |                 except Exception: pass
53 |             on_message(client, userdata, msg)
   |

E701 Multiple statements on one line (colon)
  --> bb8_core/evidence_capture.py:52:33
   |
50 |             if callable(old):
51 |                 try: old(client, userdata, msg)
52 |                 except Exception: pass
   |                                 ^
53 |             on_message(client, userdata, msg)
54 |         self.client.on_message = chained
   |

E701 Multiple statements on one line (colon)
  --> bb8_core/evidence_capture.py:62:20
   |
60 |         try:
61 |             while not self._stop.is_set() and lines < self.max_lines:
62 |                 try: cmd = self._cmd_q.get(timeout=0.5)
   |                    ^
63 |                 except queue.Empty: continue
64 |                 deadline = cmd["ts"] + self.timeout_s
   |

E701 Multiple statements on one line (colon)
  --> bb8_core/evidence_capture.py:63:35
   |
61 |             while not self._stop.is_set() and lines < self.max_lines:
62 |                 try: cmd = self._cmd_q.get(timeout=0.5)
63 |                 except queue.Empty: continue
   |                                   ^
64 |                 deadline = cmd["ts"] + self.timeout_s
65 |                 echo = None
   |

E701 Multiple statements on one line (colon)
  --> bb8_core/evidence_capture.py:67:24
   |
65 |                 echo = None
66 |                 while time.time() < deadline:
67 |                     try: evt = self._evt_q.get(timeout=deadline - time.time())
   |                        ^
68 |                     except queue.Empty: break
69 |                     if evt["topic"].split("/")[-1] == cmd["topic"].split("/")[-1]:
   |

E701 Multiple statements on one line (colon)
  --> bb8_core/evidence_capture.py:68:39
   |
66 |                 while time.time() < deadline:
67 |                     try: evt = self._evt_q.get(timeout=deadline - time.time())
68 |                     except queue.Empty: break
   |                                       ^
69 |                     if evt["topic"].split("/")[-1] == cmd["topic"].split("/")[-1]:
70 |                         echo = evt; break
   |

E702 Multiple statements on one line (semicolon)
  --> bb8_core/evidence_capture.py:70:35
   |
68 |                     except queue.Empty: break
69 |                     if evt["topic"].split("/")[-1] == cmd["topic"].split("/")[-1]:
70 |                         echo = evt; break
   |                                   ^
71 |                 record = {
72 |                     "phase": "STP4",
   |

E501 Line too long (89 > 88)
  --> bb8_core/evidence_capture.py:75:89
   |
73 |                     "cmd": cmd,
74 |                     "echo": echo,
75 |                     "latency_ms": int((echo["ts"] - cmd["ts"]) * 1000) if echo else None,
   |                                                                                         ^
76 |                     "result": "PASS" if echo else "FAIL"
77 |                 }
   |

E702 Multiple statements on one line (semicolon)
  --> bb8_core/evidence_capture.py:78:73
   |
76 |                     "result": "PASS" if echo else "FAIL"
77 |                 }
78 |                 out.write(json.dumps(record, ensure_ascii=False) + "\n"); out.flush()
   |                                                                         ^
79 |                 lines += 1
80 |         finally:
   |

I001 [*] Import block is un-sorted or un-formatted
 --> bb8_core/facade.py:1:1
  |
1 | / from __future__ import annotations
2 | | from typing import Any, Optional, Callable
3 | | import json
4 | | import threading
5 | | import time
6 | |
7 | | from .logging_setup import logger
8 | | from .bb8_presence_scanner import publish_discovery  # uses retained config payloads
9 | | from .types import BB8ControllerType  # type: ignore
  | |____________________________________^
  |
help: Organize imports

F401 [*] `.types.BB8ControllerType` imported but unused
 --> bb8_core/facade.py:9:20
  |
7 | from .logging_setup import logger
8 | from .bb8_presence_scanner import publish_discovery  # uses retained config payloads
9 | from .types import BB8ControllerType  # type: ignore
  |                    ^^^^^^^^^^^^^^^^^
  |
help: Remove unused import: `.types.BB8ControllerType`

E501 Line too long (120 > 88)
  --> bb8_core/facade.py:16:89
   |
14 |     High-level, MQTT-facing API for BB-8 Home Assistant integration.
15 |
16 |     This class wraps a BLEBridge (device driver) and exposes commands, telemetry, and Home Assistant discovery via MQTT.
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
17 |
18 |     Attributes
   |

E702 Multiple statements on one line (semicolon)
   --> bb8_core/facade.py:118:37
    |
116 |             self._publish_rejected("set_led_rgb", "offline")
117 |             return
118 |         r = max(0, min(255, int(r))); g = max(0, min(255, int(g))); b = max(0, min(255, int(b)))
    |                                     ^
119 |         self.bridge.set_led_rgb(r, g, b)
    |

E702 Multiple statements on one line (semicolon)
   --> bb8_core/facade.py:118:67
    |
116 |             self._publish_rejected("set_led_rgb", "offline")
117 |             return
118 |         r = max(0, min(255, int(r))); g = max(0, min(255, int(g))); b = max(0, min(255, int(b)))
    |                                                                   ^
119 |         self.bridge.set_led_rgb(r, g, b)
    |

E501 Line too long (96 > 88)
   --> bb8_core/facade.py:118:89
    |
116 |             self._publish_rejected("set_led_rgb", "offline")
117 |             return
118 |         r = max(0, min(255, int(r))); g = max(0, min(255, int(g))); b = max(0, min(255, int(b)))
    |                                                                                         ^^^^^^^^
119 |         self.bridge.set_led_rgb(r, g, b)
    |

E501 Line too long (117 > 88)
   --> bb8_core/facade.py:152:89
    |
151 |     # --------- MQTT wiring (subscribe/dispatch/state echo + discovery) ---------
152 |     def attach_mqtt(self, client, base_topic: str, qos: Optional[int] = None, retain: Optional[bool] = None) -> None:
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
153 |         """
154 |         Attach the facade to an MQTT client, subscribe to topics, and publish discovery and state.
    |

E501 Line too long (98 > 88)
   --> bb8_core/facade.py:154:89
    |
152 |     def attach_mqtt(self, client, base_topic: str, qos: Optional[int] = None, retain: Optional[bool] = None) -> None:
153 |         """
154 |         Attach the facade to an MQTT client, subscribe to topics, and publish discovery and state.
    |                                                                                         ^^^^^^^^^^
155 |
156 |         Parameters
    |

E501 Line too long (100 > 88)
   --> bb8_core/facade.py:172:89
    |
170 |           - {base}/power/set       ("ON"|"OFF")  → {base}/power/state
171 |           - {base}/stop/press      (any payload) → {base}/stop/state ("pressed"→"idle")
172 |           - {base}/led/set         json {"r","g","b"} | {"hex":"#rrggbb"} | "OFF" → {base}/led/state
    |                                                                                         ^^^^^^^^^^^^
173 |         Telemetry helpers (bound here):
174 |           - presence: {base}/presence/state ("ON"/"OFF")
    |

N806 Variable `CFG` in function should be lowercase
   --> bb8_core/facade.py:179:9
    |
178 |         from bb8_core.addon_config import load_config
179 |         CFG, _ = load_config()
    |         ^^^
180 |         MQTT_BASE = CFG.get("MQTT_BASE", "bb8")
181 |         HA_DISCOVERY_TOPIC = CFG.get("HA_DISCOVERY_TOPIC", "homeassistant")
    |

N806 Variable `MQTT_BASE` in function should be lowercase
   --> bb8_core/facade.py:180:9
    |
178 |         from bb8_core.addon_config import load_config
179 |         CFG, _ = load_config()
180 |         MQTT_BASE = CFG.get("MQTT_BASE", "bb8")
    |         ^^^^^^^^^
181 |         HA_DISCOVERY_TOPIC = CFG.get("HA_DISCOVERY_TOPIC", "homeassistant")
182 |         DISCOVERY_RETAIN = CFG.get("DISCOVERY_RETAIN", True)
    |

N806 Variable `HA_DISCOVERY_TOPIC` in function should be lowercase
   --> bb8_core/facade.py:181:9
    |
179 |         CFG, _ = load_config()
180 |         MQTT_BASE = CFG.get("MQTT_BASE", "bb8")
181 |         HA_DISCOVERY_TOPIC = CFG.get("HA_DISCOVERY_TOPIC", "homeassistant")
    |         ^^^^^^^^^^^^^^^^^^
182 |         DISCOVERY_RETAIN = CFG.get("DISCOVERY_RETAIN", True)
183 |         MQTT_CLIENT_ID = CFG.get("MQTT_CLIENT_ID", "bb8_presence_scanner")
    |

F841 Local variable `HA_DISCOVERY_TOPIC` is assigned to but never used
   --> bb8_core/facade.py:181:9
    |
179 |         CFG, _ = load_config()
180 |         MQTT_BASE = CFG.get("MQTT_BASE", "bb8")
181 |         HA_DISCOVERY_TOPIC = CFG.get("HA_DISCOVERY_TOPIC", "homeassistant")
    |         ^^^^^^^^^^^^^^^^^^
182 |         DISCOVERY_RETAIN = CFG.get("DISCOVERY_RETAIN", True)
183 |         MQTT_CLIENT_ID = CFG.get("MQTT_CLIENT_ID", "bb8_presence_scanner")
    |
help: Remove assignment to unused variable `HA_DISCOVERY_TOPIC`

N806 Variable `DISCOVERY_RETAIN` in function should be lowercase
   --> bb8_core/facade.py:182:9
    |
180 |         MQTT_BASE = CFG.get("MQTT_BASE", "bb8")
181 |         HA_DISCOVERY_TOPIC = CFG.get("HA_DISCOVERY_TOPIC", "homeassistant")
182 |         DISCOVERY_RETAIN = CFG.get("DISCOVERY_RETAIN", True)
    |         ^^^^^^^^^^^^^^^^
183 |         MQTT_CLIENT_ID = CFG.get("MQTT_CLIENT_ID", "bb8_presence_scanner")
184 |         BB8_NAME = CFG.get("BB8_NAME", "S33 BB84 LE")
    |

F841 Local variable `DISCOVERY_RETAIN` is assigned to but never used
   --> bb8_core/facade.py:182:9
    |
180 |         MQTT_BASE = CFG.get("MQTT_BASE", "bb8")
181 |         HA_DISCOVERY_TOPIC = CFG.get("HA_DISCOVERY_TOPIC", "homeassistant")
182 |         DISCOVERY_RETAIN = CFG.get("DISCOVERY_RETAIN", True)
    |         ^^^^^^^^^^^^^^^^
183 |         MQTT_CLIENT_ID = CFG.get("MQTT_CLIENT_ID", "bb8_presence_scanner")
184 |         BB8_NAME = CFG.get("BB8_NAME", "S33 BB84 LE")
    |
help: Remove assignment to unused variable `DISCOVERY_RETAIN`

N806 Variable `MQTT_CLIENT_ID` in function should be lowercase
   --> bb8_core/facade.py:183:9
    |
181 |         HA_DISCOVERY_TOPIC = CFG.get("HA_DISCOVERY_TOPIC", "homeassistant")
182 |         DISCOVERY_RETAIN = CFG.get("DISCOVERY_RETAIN", True)
183 |         MQTT_CLIENT_ID = CFG.get("MQTT_CLIENT_ID", "bb8_presence_scanner")
    |         ^^^^^^^^^^^^^^
184 |         BB8_NAME = CFG.get("BB8_NAME", "S33 BB84 LE")
185 |         qos_val = qos if qos is not None else CFG.get("QOS", 1)
    |

N806 Variable `BB8_NAME` in function should be lowercase
   --> bb8_core/facade.py:184:9
    |
182 |         DISCOVERY_RETAIN = CFG.get("DISCOVERY_RETAIN", True)
183 |         MQTT_CLIENT_ID = CFG.get("MQTT_CLIENT_ID", "bb8_presence_scanner")
184 |         BB8_NAME = CFG.get("BB8_NAME", "S33 BB84 LE")
    |         ^^^^^^^^
185 |         qos_val = qos if qos is not None else CFG.get("QOS", 1)
186 |         retain_val = retain if retain is not None else CFG.get("RETAIN", True)
    |

E501 Line too long (97 > 88)
   --> bb8_core/facade.py:189:89
    |
187 |         # Compose base topic from prefix and client/device ID
188 |         base_topic = f"{MQTT_BASE}/{MQTT_CLIENT_ID}"
189 |         self._mqtt = {"client": client, "base": base_topic, "qos": qos_val, "retain": retain_val}
    |                                                                                         ^^^^^^^^^
190 |
191 |         # Only one definition per local function
    |

E501 Line too long (110 > 88)
   --> bb8_core/facade.py:194:89
    |
192 |         def _pub(suffix: str, payload, r: bool = retain_val):
193 |             topic = f"{base_topic}/{suffix}"
194 |             msg = json.dumps(payload, separators=(',', ':')) if isinstance(payload, (dict, list)) else payload
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^
195 |             client.publish(topic, payload=msg, qos=qos_val, retain=r)
    |

E501 Line too long (97 > 88)
   --> bb8_core/facade.py:206:89
    |
204 |                     if "hex" in obj and isinstance(obj["hex"], str):
205 |                         h = obj["hex"].lstrip("#")
206 |                         return {"r": int(h[0:2], 16), "g": int(h[2:4], 16), "b": int(h[4:6], 16)}
    |                                                                                         ^^^^^^^^^
207 |                     return {
208 |                         "r": max(0, min(255, int(obj.get("r", 0)))),
    |

N806 Variable `REQUIRE_DEVICE_ECHO` in function should be lowercase
   --> bb8_core/facade.py:217:9
    |
216 |         import os
217 |         REQUIRE_DEVICE_ECHO = os.environ.get("REQUIRE_DEVICE_ECHO", "1") not in ("0", "false", "no", "off")
    |         ^^^^^^^^^^^^^^^^^^^
218 |         def _handle_power(_c, _u, msg):
219 |             if REQUIRE_DEVICE_ECHO:
    |

E501 Line too long (107 > 88)
   --> bb8_core/facade.py:217:89
    |
216 |         import os
217 |         REQUIRE_DEVICE_ECHO = os.environ.get("REQUIRE_DEVICE_ECHO", "1") not in ("0", "false", "no", "off")
    |                                                                                         ^^^^^^^^^^^^^^^^^^^
218 |         def _handle_power(_c, _u, msg):
219 |             if REQUIRE_DEVICE_ECHO:
    |

E501 Line too long (115 > 88)
   --> bb8_core/facade.py:220:89
    |
218 |         def _handle_power(_c, _u, msg):
219 |             if REQUIRE_DEVICE_ECHO:
220 |                 logger.warning({"event": "shim_disabled", "reason": "REQUIRE_DEVICE_ECHO=1", "topic": "power/set"})
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
221 |                 return
222 |             try:
    |

E501 Line too long (98 > 88)
   --> bb8_core/facade.py:261:89
    |
259 |         # discovery (idempotent; retained on broker)
260 |         import os
261 |         dbus_path = os.environ.get("BB8_DBUS_PATH") or CFG.get("BB8_DBUS_PATH", "/org/bluez/hci0")
    |                                                                                         ^^^^^^^^^^
262 |         publish_discovery(
263 |             client,
    |

E501 Line too long (96 > 88)
   --> bb8_core/facade.py:271:89
    |
270 |         # bind telemetry publishers for use by controller/telemetry loop
271 |         self.publish_presence = lambda online: _pub("presence/state", "ON" if online else "OFF")
    |                                                                                         ^^^^^^^^
272 |         self.publish_rssi = lambda dbm: _pub("rssi/state", str(int(dbm)))
    |

E501 Line too long (129 > 88)
   --> bb8_core/facade.py:286:89
    |
284 |             logger.info({"event": "facade_mqtt_attached", "base": base_topic})
285 |         else:
286 |             logger.warning({"event": "facade_shim_subscriptions_skipped", "reason": "REQUIRE_DEVICE_ECHO=1", "base": base_topic})
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |

I001 [*] Import block is un-sorted or un-formatted
  --> bb8_core/logging_setup.py:2:1
   |
 2 | / import json
 3 | | import logging
 4 | | import os
 5 | | import re
 6 | | import sys
 7 | | import pathlib
 8 | | import tempfile
   | |_______________^
 9 |
10 |   # Use shared config
   |
help: Organize imports

E501 Line too long (99 > 88)
  --> bb8_core/logging_setup.py:19:89
   |
18 | # Expanded redaction pattern
19 | REDACT = re.compile(r'(?i)\b(pass(word)?|token|apikey|api_key|secret|bearer)\b\s*[:=]\s*([^\s,]+)')
   |                                                                                         ^^^^^^^^^^^
20 | def redact(s: str) -> str:
21 |     return REDACT.sub(lambda m: f"{m.group(1)}=***REDACTED***", s)
   |

E501 Line too long (89 > 88)
  --> bb8_core/logging_setup.py:59:89
   |
57 |         "topic": topic,
58 |         "command": command,
59 |         "payload": {k: v for k, v in payload.items() if k != "password" and k != "token"}
   |                                                                                         ^
60 |     })
   |

E501 Line too long (89 > 88)
  --> bb8_core/logging_setup.py:79:89
   |
77 |         "event": "echo_published",
78 |         "topic": topic,
79 |         "payload": {k: v for k, v in payload.items() if k != "password" and k != "token"}
   |                                                                                         ^
80 |     })
   |

E501 Line too long (111 > 88)
  --> bb8_core/logging_setup.py:92:89
   |
90 |         return False
91 |
92 | def init_file_handler(default_path="/config/hestia/diagnostics/reports/bb8_addon_logs.log") -> logging.Handler:
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^
93 |     """
94 |     Prefer LOG_PATH from config, then BB8_LOG_PATH env, then default_path, then /tmp, then stderr.
   |

E501 Line too long (98 > 88)
  --> bb8_core/logging_setup.py:94:89
   |
92 | def init_file_handler(default_path="/config/hestia/diagnostics/reports/bb8_addon_logs.log") -> logging.Handler:
93 |     """
94 |     Prefer LOG_PATH from config, then BB8_LOG_PATH env, then default_path, then /tmp, then stderr.
   |                                                                                         ^^^^^^^^^^
95 |     Emits one warning on fallback.
96 |     """
   |

E501 Line too long (94 > 88)
   --> bb8_core/logging_setup.py:98:89
    |
 96 |     """
 97 |     candidate = _cfg.get("LOG_PATH") or os.environ.get("BB8_LOG_PATH") or default_path
 98 |     # Detect environment: if running in Home Assistant, /addons is present and /Volumes is not
    |                                                                                         ^^^^^^
 99 |     is_ha = os.path.exists("/addons") and not os.path.exists("/Volumes")
100 |     # If running in HA and candidate starts with /Volumes, strip it
    |

E501 Line too long (94 > 88)
   --> bb8_core/logging_setup.py:110:89
    |
108 |     if not _writable(candidate):
109 |         tmp = os.path.join(tempfile.gettempdir(), "bb8_addon.log")
110 |         print(f"[LOGGING DEBUG] Fallback to temp log path: {tmp}, Writable: {_writable(tmp)}")
    |                                                                                         ^^^^^^
111 |         candidate = tmp if _writable(tmp) else None
112 |         logger.warning({"event": "log_path_fallback", "target": candidate or "stderr"})
    |

E501 Line too long (175 > 88)
 --> bb8_core/mqtt_dispatcher.py:5:89
  |
3 | …
4 | …
5 | …ches commands to the BLE bridge/controller, and publishes status and discovery information for Home Assistant.
  |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
6 | …
7 | …
  |

I001 [*] Import block is un-sorted or un-formatted
  --> bb8_core/mqtt_dispatcher.py:9:1
   |
 7 |   # Finalized for Home Assistant runtime (2025-08-04)
 8 |
 9 | / from __future__ import annotations
10 | |
11 | | from typing import Optional, Any
12 | | import socket
13 | | import paho.mqtt.client as mqtt
14 | | import paho.mqtt.publish as publish  # uncommented because publish.single is used
15 | | from .logging_setup import logger
16 | | from .addon_config import load_config
   | |_____________________________________^
17 |   CFG, SRC = load_config()
   |
help: Organize imports

F401 [*] `paho.mqtt.publish` imported but unused
  --> bb8_core/mqtt_dispatcher.py:14:29
   |
12 | import socket
13 | import paho.mqtt.client as mqtt
14 | import paho.mqtt.publish as publish  # uncommented because publish.single is used
   |                             ^^^^^^^
15 | from .logging_setup import logger
16 | from .addon_config import load_config
   |
help: Remove unused import: `paho.mqtt.publish`

E501 Line too long (89 > 88)
  --> bb8_core/mqtt_dispatcher.py:91:89
   |
90 |     # Paho v2 API (compatible with our version); v311 is fine for HA
91 |     client = mqtt.Client(client_id=client_id, protocol=mqtt.MQTTv311, clean_session=True)
   |                                                                                         ^
92 |
93 |     # Auth
   |

I001 [*] Import block is un-sorted or un-formatted
   --> bb8_core/mqtt_dispatcher.py:120:21
    |
118 |               if CFG.get("DISPATCHER_DISCOVERY_ENABLED", False):
119 |                   try:
120 | /                     import os
121 | |                     from bb8_core.discovery_publish import publish_discovery
    | |____________________________________________________________________________^
122 |                       dev_id = (getattr(controller, "target_mac", None) or "bb8").replace(":", "").lower()
123 |                       dbus_path = getattr(controller, "dbus_path", None) or CFG.get("BB8_DBUS_PATH", "/org/bluez/hci0")
    |
help: Organize imports

E501 Line too long (104 > 88)
   --> bb8_core/mqtt_dispatcher.py:122:89
    |
120 |                     import os
121 |                     from bb8_core.discovery_publish import publish_discovery
122 |                     dev_id = (getattr(controller, "target_mac", None) or "bb8").replace(":", "").lower()
    |                                                                                         ^^^^^^^^^^^^^^^^
123 |                     dbus_path = getattr(controller, "dbus_path", None) or CFG.get("BB8_DBUS_PATH", "/org/bluez/hci0")
124 |                     name = os.environ.get("BB8_NAME", "BB-8")
    |

E501 Line too long (117 > 88)
   --> bb8_core/mqtt_dispatcher.py:123:89
    |
121 |                     from bb8_core.discovery_publish import publish_discovery
122 |                     dev_id = (getattr(controller, "target_mac", None) or "bb8").replace(":", "").lower()
123 |                     dbus_path = getattr(controller, "dbus_path", None) or CFG.get("BB8_DBUS_PATH", "/org/bluez/hci0")
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
124 |                     name = os.environ.get("BB8_NAME", "BB-8")
125 |                     publish_discovery(client, dev_id, dbus_path, name=name)
    |

E501 Line too long (93 > 88)
   --> bb8_core/mqtt_dispatcher.py:134:89
    |
132 |                     controller.attach_mqtt(client, mqtt_topic, qos=qos, retain=retain)
133 |                 except Exception as e:
134 |                     logger.error({"event": "controller_attach_mqtt_error", "error": repr(e)})
    |                                                                                         ^^^^^
135 |         else:
136 |             logger.error({"event": "mqtt_connect_failed", "rc": rc, "reason": reason})
    |

I001 [*] Import block is un-sorted or un-formatted
   --> bb8_core/mqtt_dispatcher.py:159:5
    |
157 |       logger.info("[BB-8] Scanning for device...")
158 |       # Lazy import to localize BLE/Sphero dependencies
159 | /     from spherov2.scanner import find_toys
160 | |     from spherov2.toy.bb8 import BB8
161 | |     from spherov2.adapter.bleak_adapter import BleakAdapter
162 | |     from spherov2.sphero_edu import SpheroEduAPI
163 | |     from spherov2.types import Color
    | |____________________________________^
164 |       devices = find_toys()
165 |       for toy in devices:
    |
help: Organize imports

I001 [*] Import block is un-sorted or un-formatted
   --> bb8_core/mqtt_dispatcher.py:182:5
    |
180 |       logger.info("[BB-8] Scanning for device to sleep...")
181 |       # Lazy import to localize BLE/Sphero dependencies
182 | /     from spherov2.scanner import find_toys
183 | |     from spherov2.toy.bb8 import BB8
184 | |     from spherov2.adapter.bleak_adapter import BleakAdapter
185 | |     from spherov2.commands.core import IntervalOptions
    | |______________________________________________________^
186 |       devices = find_toys()
187 |       for toy in devices:
    |
help: Organize imports

I001 [*] Import block is un-sorted or un-formatted
 --> bb8_core/mqtt_echo.py:1:1
  |
1 | import json
  | ^^^^^^^^^^^
2 |
3 | def echo_scalar(mqtt, base, topic, value, *, source="device"):
  |
help: Organize imports

I001 [*] Import block is un-sorted or un-formatted
  --> bb8_core/telemetry.py:2:1
   |
 2 | / from __future__ import annotations
 3 | | from typing import TYPE_CHECKING
 4 | | import threading
 5 | | import time
 6 | | import logging
 7 | | from .logging_setup import logger
 8 | | from typing import Optional, Callable
 9 | | from .types import (
10 | |     BridgeController,
11 | |     BLELink,
12 | |     BoolCallback,
13 | |     IntCallback,
14 | |     OptIntCallback,
15 | | )
   | |_^
16 |   if TYPE_CHECKING:
17 |       from .bridge_controller import BridgeController as _BridgeControllerHint
   |
help: Organize imports

F401 [*] `logging` imported but unused
 --> bb8_core/telemetry.py:6:8
  |
4 | import threading
5 | import time
6 | import logging
  |        ^^^^^^^
7 | from .logging_setup import logger
8 | from typing import Optional, Callable
  |
help: Remove unused import: `logging`

F401 [*] `.types.BridgeController` imported but unused
  --> bb8_core/telemetry.py:10:5
   |
 8 | from typing import Optional, Callable
 9 | from .types import (
10 |     BridgeController,
   |     ^^^^^^^^^^^^^^^^
11 |     BLELink,
12 |     BoolCallback,
   |
help: Remove unused import

F401 [*] `.types.BLELink` imported but unused
  --> bb8_core/telemetry.py:11:5
   |
 9 | from .types import (
10 |     BridgeController,
11 |     BLELink,
   |     ^^^^^^^
12 |     BoolCallback,
13 |     IntCallback,
   |
help: Remove unused import

F401 [*] `.types.BoolCallback` imported but unused
  --> bb8_core/telemetry.py:12:5
   |
10 |     BridgeController,
11 |     BLELink,
12 |     BoolCallback,
   |     ^^^^^^^^^^^^
13 |     IntCallback,
14 |     OptIntCallback,
   |
help: Remove unused import

F401 [*] `.types.IntCallback` imported but unused
  --> bb8_core/telemetry.py:13:5
   |
11 |     BLELink,
12 |     BoolCallback,
13 |     IntCallback,
   |     ^^^^^^^^^^^
14 |     OptIntCallback,
15 | )
   |
help: Remove unused import

F401 [*] `.types.OptIntCallback` imported but unused
  --> bb8_core/telemetry.py:14:5
   |
12 |     BoolCallback,
13 |     IntCallback,
14 |     OptIntCallback,
   |     ^^^^^^^^^^^^^^
15 | )
16 | if TYPE_CHECKING:
   |
help: Remove unused import

F401 [*] `.bridge_controller.BridgeController` imported but unused
  --> bb8_core/telemetry.py:17:56
   |
15 | )
16 | if TYPE_CHECKING:
17 |     from .bridge_controller import BridgeController as _BridgeControllerHint
   |                                                        ^^^^^^^^^^^^^^^^^^^^^
18 |
19 | class Telemetry:
   |
help: Remove unused import: `.bridge_controller.BridgeController`

E501 Line too long (98 > 88)
  --> bb8_core/telemetry.py:66:89
   |
64 |                         cb_presence(online)
65 |                     except Exception as e:
66 |                         logger.warning({"event": "telemetry_presence_cb_error", "error": repr(e)})
   |                                                                                         ^^^^^^^^^^
67 |
68 |                 # --- rssi probe ---
   |

E501 Line too long (97 > 88)
  --> bb8_core/telemetry.py:75:89
   |
73 |                         dbm = get_rssi()
74 |                     except Exception as e:
75 |                         logger.warning({"event": "telemetry_rssi_probe_error", "error": repr(e)})
   |                                                                                         ^^^^^^^^^
76 |
77 |                 # --- rssi publish ---
   |

E501 Line too long (97 > 88)
  --> bb8_core/telemetry.py:86:89
   |
84 |                             cb_rssi(int(dbm))
85 |                         else:
86 |                             logger.warning({"event": "telemetry_invalid_rssi", "dbm": repr(dbm)})
   |                                                                                         ^^^^^^^^^
87 |                     except Exception as e:
88 |                         logger.warning({"event": "telemetry_rssi_cb_error", "error": repr(e)})
   |

E501 Line too long (94 > 88)
  --> bb8_core/telemetry.py:88:89
   |
86 |                             logger.warning({"event": "telemetry_invalid_rssi", "dbm": repr(dbm)})
87 |                     except Exception as e:
88 |                         logger.warning({"event": "telemetry_rssi_cb_error", "error": repr(e)})
   |                                                                                         ^^^^^^
89 |             except Exception as e:
90 |                 logger.warning({"event": "telemetry_error", "error": repr(e)})
   |

I001 [*] Import block is un-sorted or un-formatted
  --> bb8_core/types.py:2:1
   |
 1 |   # beep_boop_bb8/bb8_core/types.py
 2 | / from __future__ import annotations
 3 | |
 4 | | from typing import (
 5 | |     Any,
 6 | |     Callable,
 7 | |     Dict,
 8 | |     Optional,
 9 | |     Tuple,
10 | |     Protocol,
11 | |     runtime_checkable,
12 | |     TYPE_CHECKING,
13 | | )
   | |_^
14 |
15 |   # ---------------------------
   |
help: Organize imports

F401 [*] `typing.Dict` imported but unused
 --> bb8_core/types.py:7:5
  |
5 |     Any,
6 |     Callable,
7 |     Dict,
  |     ^^^^
8 |     Optional,
9 |     Tuple,
  |
help: Remove unused import

F401 [*] `typing.TYPE_CHECKING` imported but unused
  --> bb8_core/types.py:12:5
   |
10 |     Protocol,
11 |     runtime_checkable,
12 |     TYPE_CHECKING,
   |     ^^^^^^^^^^^^^
13 | )
   |
help: Remove unused import

E501 Line too long (92 > 88)
  --> bb8_core/types.py:19:89
   |
17 | # ---------------------------
18 | RGB = Tuple[int, int, int]
19 | Scalar = "Scalar"  # alias for readable callbacks below (string-based to avoid 3.8 | syntax)
   |                                                                                         ^^^^
20 |
21 | # NB: Avoid importing any local modules at runtime to prevent cycles.
   |

E501 Line too long (95 > 88)
  --> bb8_core/types.py:41:89
   |
39 | # ---------------------------
40 | class MqttClient(Protocol):
41 |     def publish(self, topic: str, payload: str, qos: int = ..., retain: bool = ...) -> Any: ...
   |                                                                                         ^^^^^^^
   |

E501 Line too long (97 > 88)
  --> bb8_core/types.py:79:89
   |
77 |     base_topic: str
78 |
79 |     def publish_scalar_echo(self, topic: str, value: Any, *, source: str = "facade") -> None: ...
   |                                                                                         ^^^^^^^^^
80 |     def publish_led_echo(self, r: int, g: int, b: int) -> None: ...
   |

I001 [*] Import block is un-sorted or un-formatted
 --> bb8_core/util.py:1:1
  |
1 | from .logging_setup import logger
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
2 |
3 | def clamp(x: int, lo: int, hi: int) -> int:
  |
help: Organize imports

E701 Multiple statements on one line (colon)
 --> bb8_core/util.py:5:14
  |
3 | def clamp(x: int, lo: int, hi: int) -> int:
4 |     logger.debug({"event": "util_clamp", "x": x, "lo": lo, "hi": hi})
5 |     if x < lo: return lo
  |              ^
6 |     if x > hi: return hi
7 |     return x
  |

E701 Multiple statements on one line (colon)
 --> bb8_core/util.py:6:14
  |
4 |     logger.debug({"event": "util_clamp", "x": x, "lo": lo, "hi": hi})
5 |     if x < lo: return lo
6 |     if x > hi: return hi
  |              ^
7 |     return x
  |

I001 [*] Import block is un-sorted or un-formatted
 --> bb8_core/version_probe.py:3:1
  |
1 | # bb8_core/version_probe.py
2 |
3 | from importlib.metadata import version, PackageNotFoundError as E
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
4 |
5 | def probe():
  |
help: Organize imports

I001 [*] Import block is un-sorted or un-formatted
 --> ops/blebridge_handler_surface_check.py:1:1
  |
1 | from bb8_core.ble_bridge import BLEBridge
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
2 |
3 | class Gw:
  |
help: Organize imports

E501 Line too long (97 > 88)
  --> ops/blebridge_handler_surface_check.py:9:89
   |
 7 | gw = Gw()
 8 | b = BLEBridge(gw, target_mac="00:11:22:33:44:55", ble_adapter="hci0")
 9 | for name in ("power", "stop", "set_led_off", "set_led_rgb", "sleep", "is_connected", "get_rssi"):
   |                                                                                         ^^^^^^^^^
10 |     print(name, hasattr(b, name), getattr(b, name))
   |

E501 Line too long (89 > 88)
 --> ops/evidence/collect_stp4.py:7:89
  |
5 | Outputs:
6 |   - ha_discovery_dump.json      # retained discovery configs observed
7 |   - ha_mqtt_trace_snapshot.json # per-entity command→state traces w/ timestamps & latency
  |                                                                                         ^
8 |   - evidence_manifest.json      # summary, pass/fail attestation
9 | Exit code:
  |

E401 [*] Multiple imports on one line
  --> ops/evidence/collect_stp4.py:14:1
   |
14 | import argparse, json, os, sys, time, threading
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
15 | from datetime import datetime, timezone
16 | from typing import Dict, Any, List, Tuple, Optional
   |
help: Split imports

I001 [*] Import block is un-sorted or un-formatted
  --> ops/evidence/collect_stp4.py:14:1
   |
14 | / import argparse, json, os, sys, time, threading
15 | | from datetime import datetime, timezone
16 | | from typing import Dict, Any, List, Tuple, Optional
   | |___________________________________________________^
17 |
18 |   # Use shared config
   |
help: Organize imports

E501 Line too long (100 > 88)
  --> ops/evidence/collect_stp4.py:23:89
   |
21 | except ImportError:
22 |     # Fallback assignment: If the import fails, set load_config to None.
23 |     # This allows the script to run outside the package context where bb8_core may not be available.
   |                                                                                         ^^^^^^^^^^^^
24 |     load_config = None
   |

E501 Line too long (172 > 88)
  --> ops/evidence/collect_stp4.py:32:89
   |
30 | …
31 | …
32 | …port failed: {e}. This usually means the virtual environment is not activated or dependencies are missing.")
   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
33 | … file=sys.stderr)
34 | …
   |

E501 Line too long (148 > 88)
  --> ops/evidence/collect_stp4.py:46:89
   |
44 | …
45 | …G)
46 | … failed: {e}. This may indicate a missing config file, broken loader, or missing dependencies.")
   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
47 | …e}", file=sys.stderr)
48 | …
   |

E501 Line too long (131 > 88)
  --> ops/evidence/collect_stp4.py:49:89
   |
47 |             print(f"[ERROR] Failed to load config: {e}", file=sys.stderr)
48 |             return {}
49 |     logging.warning("[CONFIG] load_config is not available. This usually means the module import failed or PYTHONPATH is not set.")
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
50 |     return {}
   |

E501 Line too long (100 > 88)
  --> ops/evidence/collect_stp4.py:63:89
   |
61 |     })
62 |     p = argparse.ArgumentParser()
63 |     p.add_argument("--host", default=cfg.get("MQTT_HOST", os.environ.get("MQTT_HOST", "localhost")))
   |                                                                                         ^^^^^^^^^^^^
64 |     p.add_argument("--port", type=int, default=int(cfg.get("MQTT_PORT", os.environ.get("MQTT_PORT", "1883"))))
65 |     p.add_argument("--user", default=cfg.get("MQTT_USERNAME", os.environ.get("MQTT_USER")))
   |

E501 Line too long (110 > 88)
  --> ops/evidence/collect_stp4.py:64:89
   |
62 |     p = argparse.ArgumentParser()
63 |     p.add_argument("--host", default=cfg.get("MQTT_HOST", os.environ.get("MQTT_HOST", "localhost")))
64 |     p.add_argument("--port", type=int, default=int(cfg.get("MQTT_PORT", os.environ.get("MQTT_PORT", "1883"))))
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^
65 |     p.add_argument("--user", default=cfg.get("MQTT_USERNAME", os.environ.get("MQTT_USER")))
66 |     p.add_argument("--password", default=cfg.get("MQTT_PASSWORD", os.environ.get("MQTT_PASSWORD")))
   |

E501 Line too long (91 > 88)
  --> ops/evidence/collect_stp4.py:65:89
   |
63 |     p.add_argument("--host", default=cfg.get("MQTT_HOST", os.environ.get("MQTT_HOST", "localhost")))
64 |     p.add_argument("--port", type=int, default=int(cfg.get("MQTT_PORT", os.environ.get("MQTT_PORT", "1883"))))
65 |     p.add_argument("--user", default=cfg.get("MQTT_USERNAME", os.environ.get("MQTT_USER")))
   |                                                                                         ^^^
66 |     p.add_argument("--password", default=cfg.get("MQTT_PASSWORD", os.environ.get("MQTT_PASSWORD")))
67 |     p.add_argument("--base", default=cfg.get("MQTT_BASE", os.environ.get("MQTT_BASE", "bb8")))
   |

E501 Line too long (99 > 88)
  --> ops/evidence/collect_stp4.py:66:89
   |
64 |     p.add_argument("--port", type=int, default=int(cfg.get("MQTT_PORT", os.environ.get("MQTT_PORT", "1883"))))
65 |     p.add_argument("--user", default=cfg.get("MQTT_USERNAME", os.environ.get("MQTT_USER")))
66 |     p.add_argument("--password", default=cfg.get("MQTT_PASSWORD", os.environ.get("MQTT_PASSWORD")))
   |                                                                                         ^^^^^^^^^^^
67 |     p.add_argument("--base", default=cfg.get("MQTT_BASE", os.environ.get("MQTT_BASE", "bb8")))
68 |     p.add_argument("--out", default="reports/stp4_"+datetime.now().strftime("%Y%m%d_%H%M%S"))
   |

E501 Line too long (94 > 88)
  --> ops/evidence/collect_stp4.py:67:89
   |
65 |     p.add_argument("--user", default=cfg.get("MQTT_USERNAME", os.environ.get("MQTT_USER")))
66 |     p.add_argument("--password", default=cfg.get("MQTT_PASSWORD", os.environ.get("MQTT_PASSWORD")))
67 |     p.add_argument("--base", default=cfg.get("MQTT_BASE", os.environ.get("MQTT_BASE", "bb8")))
   |                                                                                         ^^^^^^
68 |     p.add_argument("--out", default="reports/stp4_"+datetime.now().strftime("%Y%m%d_%H%M%S"))
69 |     p.add_argument("--timeout", type=float, default=2.0, help="State echo timeout seconds")
   |

E501 Line too long (93 > 88)
  --> ops/evidence/collect_stp4.py:68:89
   |
66 |     p.add_argument("--password", default=cfg.get("MQTT_PASSWORD", os.environ.get("MQTT_PASSWORD")))
67 |     p.add_argument("--base", default=cfg.get("MQTT_BASE", os.environ.get("MQTT_BASE", "bb8")))
68 |     p.add_argument("--out", default="reports/stp4_"+datetime.now().strftime("%Y%m%d_%H%M%S"))
   |                                                                                         ^^^^^
69 |     p.add_argument("--timeout", type=float, default=2.0, help="State echo timeout seconds")
70 |     return p.parse_args()
   |

E501 Line too long (91 > 88)
  --> ops/evidence/collect_stp4.py:69:89
   |
67 |     p.add_argument("--base", default=cfg.get("MQTT_BASE", os.environ.get("MQTT_BASE", "bb8")))
68 |     p.add_argument("--out", default="reports/stp4_"+datetime.now().strftime("%Y%m%d_%H%M%S"))
69 |     p.add_argument("--timeout", type=float, default=2.0, help="State echo timeout seconds")
   |                                                                                         ^^^
70 |     return p.parse_args()
   |

E702 Multiple statements on one line (semicolon)
   --> ops/evidence/collect_stp4.py:126:88
    |
124 |         missing = [k for k in req if k not in o]
125 |         if missing:
126 |             results.append({"topic":topic,"valid":False,"reason":f"missing:{missing}"}); ok=False; continue
    |                                                                                        ^
127 |         if o["device"].get("identifiers") in (None, [],):
128 |             results.append({"topic":topic,"valid":False,"reason":"device.identifiers missing"}); ok=False; continue
    |

E501 Line too long (107 > 88)
   --> ops/evidence/collect_stp4.py:126:89
    |
124 |         missing = [k for k in req if k not in o]
125 |         if missing:
126 |             results.append({"topic":topic,"valid":False,"reason":f"missing:{missing}"}); ok=False; continue
    |                                                                                         ^^^^^^^^^^^^^^^^^^^
127 |         if o["device"].get("identifiers") in (None, [],):
128 |             results.append({"topic":topic,"valid":False,"reason":"device.identifiers missing"}); ok=False; continue
    |

E702 Multiple statements on one line (semicolon)
   --> ops/evidence/collect_stp4.py:126:98
    |
124 |         missing = [k for k in req if k not in o]
125 |         if missing:
126 |             results.append({"topic":topic,"valid":False,"reason":f"missing:{missing}"}); ok=False; continue
    |                                                                                                  ^
127 |         if o["device"].get("identifiers") in (None, [],):
128 |             results.append({"topic":topic,"valid":False,"reason":"device.identifiers missing"}); ok=False; continue
    |

E501 Line too long (115 > 88)
   --> ops/evidence/collect_stp4.py:128:89
    |
126 |             results.append({"topic":topic,"valid":False,"reason":f"missing:{missing}"}); ok=False; continue
127 |         if o["device"].get("identifiers") in (None, [],):
128 |             results.append({"topic":topic,"valid":False,"reason":"device.identifiers missing"}); ok=False; continue
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
129 |         # commandables need command_topic
130 |         if any(x in topic for x in ("/light/","/switch/","/button/","/number/")):
    |

E702 Multiple statements on one line (semicolon)
   --> ops/evidence/collect_stp4.py:128:96
    |
126 |             results.append({"topic":topic,"valid":False,"reason":f"missing:{missing}"}); ok=False; continue
127 |         if o["device"].get("identifiers") in (None, [],):
128 |             results.append({"topic":topic,"valid":False,"reason":"device.identifiers missing"}); ok=False; continue
    |                                                                                                ^
129 |         # commandables need command_topic
130 |         if any(x in topic for x in ("/light/","/switch/","/button/","/number/")):
    |

E702 Multiple statements on one line (semicolon)
   --> ops/evidence/collect_stp4.py:128:106
    |
126 |             results.append({"topic":topic,"valid":False,"reason":f"missing:{missing}"}); ok=False; continue
127 |         if o["device"].get("identifiers") in (None, [],):
128 |             results.append({"topic":topic,"valid":False,"reason":"device.identifiers missing"}); ok=False; continue
    |                                                                                                          ^
129 |         # commandables need command_topic
130 |         if any(x in topic for x in ("/light/","/switch/","/button/","/number/")):
    |

E501 Line too long (114 > 88)
   --> ops/evidence/collect_stp4.py:132:89
    |
130 |         if any(x in topic for x in ("/light/","/switch/","/button/","/number/")):
131 |             if "command_topic" not in o:
132 |                 results.append({"topic":topic,"valid":False,"reason":"command_topic missing"}); ok=False; continue
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
133 |         results.append({"topic":topic,"valid":True})
134 |     return {"valid": ok, "count": len(relevant), "details": results}
    |

E702 Multiple statements on one line (semicolon)
   --> ops/evidence/collect_stp4.py:132:95
    |
130 |         if any(x in topic for x in ("/light/","/switch/","/button/","/number/")):
131 |             if "command_topic" not in o:
132 |                 results.append({"topic":topic,"valid":False,"reason":"command_topic missing"}); ok=False; continue
    |                                                                                               ^
133 |         results.append({"topic":topic,"valid":True})
134 |     return {"valid": ok, "count": len(relevant), "details": results}
    |

E702 Multiple statements on one line (semicolon)
   --> ops/evidence/collect_stp4.py:132:105
    |
130 |         if any(x in topic for x in ("/light/","/switch/","/button/","/number/")):
131 |             if "command_topic" not in o:
132 |                 results.append({"topic":topic,"valid":False,"reason":"command_topic missing"}); ok=False; continue
    |                                                                                                         ^
133 |         results.append({"topic":topic,"valid":True})
134 |     return {"valid": ok, "count": len(relevant), "details": results}
    |

E501 Line too long (131 > 88)
   --> ops/evidence/collect_stp4.py:138:89
    |
136 | # ----- collector -----
137 | class Collector:
138 |     def __init__(self, host: str, port: int, user: Optional[str], password: Optional[str], base: str, outdir: str, timeout: float):
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
139 |         self.host, self.port, self.user, self.password = host, port, user, password
140 |         self.base, self.outdir, self.timeout = base, outdir, timeout
    |

E501 Line too long (94 > 88)
   --> ops/evidence/collect_stp4.py:193:89
    |
191 |                 }
192 |             except Exception as e:
193 |                 self.discovery_dump[msg.topic] = {"valid": False, "reason": f"json_error:{e}"}
    |                                                                                         ^^^^^^
194 |         # log and notify
195 |         with self.msg_cv:
    |

E501 Line too long (96 > 88)
   --> ops/evidence/collect_stp4.py:199:89
    |
197 |             self.msg_cv.notify_all()
198 |
199 |     def wait_for_topic(self, topic: str, predicate, timeout: float) -> Optional[Dict[str, Any]]:
    |                                                                                         ^^^^^^^^
200 |         deadline = time.time() + timeout
201 |         with self.msg_cv:
    |

E701 Multiple statements on one line (colon)
   --> ops/evidence/collect_stp4.py:210:34
    |
208 |             while time.time() < deadline:
209 |                 remaining = deadline - time.time()
210 |                 if remaining <= 0: break
    |                                  ^
211 |                 self.msg_cv.wait(timeout=remaining)
212 |                 for m in reversed(self.msg_log):
    |

E501 Line too long (89 > 88)
   --> ops/evidence/collect_stp4.py:214:89
    |
212 |                 for m in reversed(self.msg_log):
213 |                     if m["topic"] == topic and predicate(m):
214 |                         # Only accept state with ts >= command_ts (reject stale/prestate)
    |                                                                                         ^
215 |                         return self._extract_state(m)
216 |         return None
    |

E501 Line too long (90 > 88)
   --> ops/evidence/collect_stp4.py:236:89
    |
234 |         self.client.on_connect = self.on_connect
235 |         self.client.on_message = self.on_message
236 |         self.client.will_set(f"{self.base}/status", payload="offline", qos=1, retain=True)
    |                                                                                         ^^
237 |         self.client.connect(self.host, self.port, keepalive=60)
238 |         self.client.loop_start()
    |

E722 Do not use bare `except`
   --> ops/evidence/collect_stp4.py:247:13
    |
245 |             try:
246 |                 self.client.disconnect()
247 |             except:
    |             ^^^^^^
248 |                 pass
    |

E501 Line too long (90 > 88)
   --> ops/evidence/collect_stp4.py:281:89
    |
280 |         def record(entity: str, cmd_t: str, cmd_p: str, state_t: str, expect,
281 |                    m: Optional[Dict[str, Any]], note: str="", cmd_ts: Optional[str]=None):
    |                                                                                         ^^
282 |             now = cmd_ts or utc_now_iso()
283 |             cmd = {
    |

E501 Line too long (121 > 88)
   --> ops/evidence/collect_stp4.py:305:89
    |
303 |                     cmd_dt = parse_time(cmd["command_ts"])
304 |                     skew = abs((state_dt - cmd_dt).total_seconds())
305 |                     if echo["state_ts"] >= cmd["command_ts"] or (echo["state_ts"] < cmd["command_ts"] and skew <= 0.050):
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
306 |                         try:
307 |                             # 1) exact raw match first
    |

E501 Line too long (102 > 88)
   --> ops/evidence/collect_stp4.py:322:89
    |
320 | …                         pass
321 | …                     # 2) JSON==JSON structural equality (e.g. LED RGB)
322 | …                     if j_echo is not None and j_expect is not None and j_echo == j_expect:
    |                                                                               ^^^^^^^^^^^^^^
323 | …                         passed, note_val = True, ""
324 | …                     # 3) JSON with {"value": ...} vs raw expect (strings or numbers)
    |

E501 Line too long (96 > 88)
   --> ops/evidence/collect_stp4.py:324:89
    |
322 | …                     if j_echo is not None and j_expect is not None and j_echo == j_expect:
323 | …                         passed, note_val = True, ""
324 | …                     # 3) JSON with {"value": ...} vs raw expect (strings or numbers)
    |                                                                               ^^^^^^^^
325 | …                     elif isinstance(j_echo, dict) and "value" in j_echo and str(j_echo["value"]).strip() == str(expect).strip():
326 | …                         passed, note_val = True, ""
    |

E501 Line too long (140 > 88)
   --> ops/evidence/collect_stp4.py:325:89
    |
323 | …                         passed, note_val = True, ""
324 | …                     # 3) JSON with {"value": ...} vs raw expect (strings or numbers)
325 | …                     elif isinstance(j_echo, dict) and "value" in j_echo and str(j_echo["value"]).strip() == str(expect).strip():
    |                                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
326 | …                         passed, note_val = True, ""
327 | …                     # 4) final string fallback
    |

E501 Line too long (95 > 88)
   --> ops/evidence/collect_stp4.py:328:89
    |
326 | …                         passed, note_val = True, ""
327 | …                     # 4) final string fallback
328 | …                     elif str(echo["state_payload"]).strip() == str(expect).strip():
    |                                                                               ^^^^^^^
329 | …                         passed, note_val = True, ""
330 | …                     else:
    |

E501 Line too long (89 > 88)
   --> ops/evidence/collect_stp4.py:333:89
    |
331 |                                     note_val = "mismatch"
332 |                         except Exception:
333 |                             if str(echo["state_payload"]).strip() == str(expect).strip():
    |                                                                                         ^
334 |                                 passed, note_val = True, ""
335 |                             else:
    |

E501 Line too long (188 > 88)
   --> ops/evidence/collect_stp4.py:342:89
    |
340 | …!= "0")
341 | …set")
342 | …DEVICE_ECHO')}, require_device={require_device}, is_commandable={is_commandable}, echo_source={echo.get('source')}")
    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
343 | …e") != "device":
344 | …
    |

E701 Multiple statements on one line (colon)
   --> ops/evidence/collect_stp4.py:368:44
    |
366 |             # Accept raw "ON" or JSON with value "ON"
367 |             try:
368 |                 if x["payload_raw"] == "ON": return True
    |                                            ^
369 |                 j = json.loads(x["payload_raw"])
370 |                 return j.get("value") == "ON"
    |

E501 Line too long (97 > 88)
   --> ops/evidence/collect_stp4.py:374:89
    |
372 |                 return False
373 |         m = self.wait_for_topic(f"{base}/power/state", power_pred, to)
374 |         record("power_on", f"{base}/power/set", "ON", f"{base}/power/state", "ON", m, cmd_ts=_ts)
    |                                                                                         ^^^^^^^^^
375 |
376 |         # stop press -> 'pressed' then 'idle'
    |

E501 Line too long (105 > 88)
   --> ops/evidence/collect_stp4.py:379:89
    |
377 |         _ts = self.publish(f"{base}/stop/press", None)
378 |         m1 = self.wait_for_topic(f"{base}/stop/state",   val_pred("pressed"), to)
379 |         record("stop_pressed", f"{base}/stop/press", "", f"{base}/stop/state", "pressed", m1, cmd_ts=_ts)
    |                                                                                         ^^^^^^^^^^^^^^^^^
380 |         m2 = self.wait_for_topic(f"{base}/stop/state",   val_pred("idle"),    to+1.0)
381 |         record("stop_idle", f"{base}/stop/press", "", f"{base}/stop/state", "idle", m2, cmd_ts=_ts)
    |

E501 Line too long (99 > 88)
   --> ops/evidence/collect_stp4.py:381:89
    |
379 |         record("stop_pressed", f"{base}/stop/press", "", f"{base}/stop/state", "pressed", m1, cmd_ts=_ts)
380 |         m2 = self.wait_for_topic(f"{base}/stop/state",   val_pred("idle"),    to+1.0)
381 |         record("stop_idle", f"{base}/stop/press", "", f"{base}/stop/state", "idle", m2, cmd_ts=_ts)
    |                                                                                         ^^^^^^^^^^^
382 |
383 |         # led set -> hex color
    |

E501 Line too long (144 > 88)
   --> ops/evidence/collect_stp4.py:398:89
    |
397 | …tained (no command)
398 | …ce/state", lambda x: x["payload_raw"] is not None and str(x["payload_raw"]).strip() != "", to)
    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
399 | …
400 | …
    |

E501 Line too long (140 > 88)
   --> ops/evidence/collect_stp4.py:407:89
    |
405 | …
406 | …
407 | …/state", lambda x: x["payload_raw"] is not None and str(x["payload_raw"]).strip() != "", to)
    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
408 | …
409 | …
    |

E501 Line too long (106 > 88)
   --> ops/evidence/collect_stp4.py:421:89
    |
419 |         _ts = self.publish(f"{base}/sleep/press", None)
420 |         m1 = self.wait_for_topic(f"{base}/sleep/state",  val_pred("pressed"), to)
421 |         record("sleep_pressed", f"{base}/sleep/press","", f"{base}/sleep/state","pressed", m1, cmd_ts=_ts)
    |                                                                                         ^^^^^^^^^^^^^^^^^^
422 |         m2 = self.wait_for_topic(f"{base}/sleep/state",  val_pred("idle"),    to+1.0)
423 |         record("sleep_idle", f"{base}/sleep/press","", f"{base}/sleep/state","idle", m2, cmd_ts=_ts)
    |

E501 Line too long (100 > 88)
   --> ops/evidence/collect_stp4.py:423:89
    |
421 |         record("sleep_pressed", f"{base}/sleep/press","", f"{base}/sleep/state","pressed", m1, cmd_ts=_ts)
422 |         m2 = self.wait_for_topic(f"{base}/sleep/state",  val_pred("idle"),    to+1.0)
423 |         record("sleep_idle", f"{base}/sleep/press","", f"{base}/sleep/state","idle", m2, cmd_ts=_ts)
    |                                                                                         ^^^^^^^^^^^^
424 |
425 |         # heading number
    |

E501 Line too long (95 > 88)
   --> ops/evidence/collect_stp4.py:427:89
    |
425 |         # heading number
426 |         _ts = self.publish(f"{base}/heading/set", "270")
427 |         m = self.wait_for_topic(f"{base}/heading/state", lambda x: x["payload_raw"]=="270", to)
    |                                                                                         ^^^^^^^
428 |         record("heading_set_270", f"{base}/heading/set","270", f"{base}/heading/state","270", m, cmd_ts=_ts)
    |

E501 Line too long (108 > 88)
   --> ops/evidence/collect_stp4.py:428:89
    |
426 |         _ts = self.publish(f"{base}/heading/set", "270")
427 |         m = self.wait_for_topic(f"{base}/heading/state", lambda x: x["payload_raw"]=="270", to)
428 |         record("heading_set_270", f"{base}/heading/set","270", f"{base}/heading/state","270", m, cmd_ts=_ts)
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^
429 |
430 |         # speed number
    |

E501 Line too long (93 > 88)
   --> ops/evidence/collect_stp4.py:432:89
    |
430 |         # speed number
431 |         _ts = self.publish(f"{base}/speed/set", "128")
432 |         m = self.wait_for_topic(f"{base}/speed/state", lambda x: x["payload_raw"]=="128", to)
    |                                                                                         ^^^^^
433 |         record("speed_set_128", f"{base}/speed/set","128", f"{base}/speed/state","128", m, cmd_ts=_ts)
    |

E501 Line too long (102 > 88)
   --> ops/evidence/collect_stp4.py:433:89
    |
431 |         _ts = self.publish(f"{base}/speed/set", "128")
432 |         m = self.wait_for_topic(f"{base}/speed/state", lambda x: x["payload_raw"]=="128", to)
433 |         record("speed_set_128", f"{base}/speed/set","128", f"{base}/speed/state","128", m, cmd_ts=_ts)
    |                                                                                         ^^^^^^^^^^^^^^
434 |
435 |         # drive button
    |

E501 Line too long (106 > 88)
   --> ops/evidence/collect_stp4.py:438:89
    |
436 |         _ts = self.publish(f"{base}/drive/press", None)
437 |         m1 = self.wait_for_topic(f"{base}/drive/state",  val_pred("pressed"), to)
438 |         record("drive_pressed", f"{base}/drive/press","", f"{base}/drive/state","pressed", m1, cmd_ts=_ts)
    |                                                                                         ^^^^^^^^^^^^^^^^^^
439 |         m2 = self.wait_for_topic(f"{base}/drive/state",  val_pred("idle"),    to+1.0)
440 |         record("drive_idle", f"{base}/drive/press","", f"{base}/drive/state","idle", m2,cmd_ts=_ts)
    |

E501 Line too long (99 > 88)
   --> ops/evidence/collect_stp4.py:440:89
    |
438 |         record("drive_pressed", f"{base}/drive/press","", f"{base}/drive/state","pressed", m1, cmd_ts=_ts)
439 |         m2 = self.wait_for_topic(f"{base}/drive/state",  val_pred("idle"),    to+1.0)
440 |         record("drive_idle", f"{base}/drive/press","", f"{base}/drive/state","idle", m2,cmd_ts=_ts)
    |                                                                                         ^^^^^^^^^^^
441 |
442 |         # ----- dump artifacts -----
    |

E501 Line too long (91 > 88)
   --> ops/evidence/collect_stp4.py:444:89
    |
442 |         # ----- dump artifacts -----
443 |         ensure_dir(self.outdir)
444 |         dump_json(os.path.join(self.outdir, "ha_discovery_dump.json"), self.discovery_dump)
    |                                                                                         ^^^
445 |         dump_json(os.path.join(self.outdir, "ha_mqtt_trace_snapshot.json"), traces)
    |

E501 Line too long (96 > 88)
   --> ops/evidence/collect_stp4.py:457:89
    |
456 |         # Prepare configs as (topic, payload) tuples from discovery_dump
457 |         configs = [(topic, entry["obj"] if isinstance(entry, dict) and "obj" in entry else "{}")
    |                                                                                         ^^^^^^^^
458 |                    for topic, entry in self.discovery_dump.items()]
459 |         # Convert obj back to JSON string for validation
    |

E501 Line too long (104 > 88)
   --> ops/evidence/collect_stp4.py:460:89
    |
458 |                    for topic, entry in self.discovery_dump.items()]
459 |         # Convert obj back to JSON string for validation
460 |         configs = [(topic, json.dumps(obj) if isinstance(obj, dict) else obj) for topic, obj in configs]
    |                                                                                         ^^^^^^^^^^^^^^^^
461 |
462 |         schema_result = validate_discovery(configs, device_identifiers=dev_ids, base_topic=os.getenv("MQTT_BASE","bb8"))
    |

E501 Line too long (120 > 88)
   --> ops/evidence/collect_stp4.py:462:89
    |
460 |         configs = [(topic, json.dumps(obj) if isinstance(obj, dict) else obj) for topic, obj in configs]
461 |
462 |         schema_result = validate_discovery(configs, device_identifiers=dev_ids, base_topic=os.getenv("MQTT_BASE","bb8"))
    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
463 |         disc_ok = schema_result["valid"]
464 |         roundtrip_ok = all(t.get("pass") for t in traces if isinstance(t, dict))
    |

E501 Line too long (94 > 88)
   --> ops/evidence/collect_stp4.py:468:89
    |
466 |         attn = {
467 |             "generated_at": utc_now_iso(),
468 |             "broker": {"host": self.host, "port": self.port, "user_present": bool(self.user)},
    |                                                                                         ^^^^^^
469 |             "base_topic": self.base,
470 |             "schema": "PASS" if disc_ok else "FAIL",
    |

E501 Line too long (148 > 88)
   --> ops/evidence/collect_stp4.py:473:89
    |
471 | …
472 | … "FAIL",
473 | …d roundtrip_ok) else "FAIL") + (" (explain if FAIL)" if not (disc_ok and roundtrip_ok) else ""),
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
474 | …
475 | …mqtt_trace_snapshot.json"]
    |

E501 Line too long (102 > 88)
   --> ops/evidence/collect_stp4.py:485:89
    |
483 |     args = parse_args()
484 |     ensure_dir(args.out)
485 |     col = Collector(args.host, args.port, args.user, args.password, args.base, args.out, args.timeout)
    |                                                                                         ^^^^^^^^^^^^^^
486 |     res = col.run()
487 |     print(json.dumps(res["attestation"], indent=2))
    |

I001 [*] Import block is un-sorted or un-formatted
 --> ops/evidence/evidence_capture.py:1:1
  |
1 | / from __future__ import annotations
2 | | import json, time, threading, queue, os
3 | | from typing import Any, Dict, Optional
  | |______________________________________^
4 |
5 |   """
  |
help: Organize imports

E401 [*] Multiple imports on one line
 --> ops/evidence/evidence_capture.py:2:1
  |
1 | from __future__ import annotations
2 | import json, time, threading, queue, os
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
3 | from typing import Any, Dict, Optional
  |
help: Split imports

E501 Line too long (284 > 88)
 --> ops/evidence/evidence_capture.py:6:89
  |
5 | …
6 | …hing not "device" becomes facade_only). That logic is sound—keep it. Use REQUIRE_DEVICE_ECHO=0 while the shim stands in, then flip to 1 for real hardware acceptance. (See the env/logic in record(...).)
  |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
7 | …
8 | …
  |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:9:1
   |
 7 | """
 8 | class EvidenceRecorder:
 9 |     """
   | ^^^^
10 |     Subscribes to command and state topics and records round-trip evidence.
11 |     Constraints:
   |

E101 Indentation contains mixed spaces and tabs
  --> ops/evidence/evidence_capture.py:12:1
   |
10 |     Subscribes to command and state topics and records round-trip evidence.
11 |     Constraints:
12 |       - Single publisher (façade) policy remains intact; this only records.
   | ^^^^^^
13 |       - Writes JSON lines to reports/ha_mqtt_trace_snapshot.jsonl (≤150 lines).
14 |     """
   |

E101 Indentation contains mixed spaces and tabs
  --> ops/evidence/evidence_capture.py:13:1
   |
11 |     Constraints:
12 |       - Single publisher (façade) policy remains intact; this only records.
13 |       - Writes JSON lines to reports/ha_mqtt_trace_snapshot.jsonl (≤150 lines).
   | ^^^^^^
14 |     """
15 |     def __init__(self, client, topic_prefix: str, report_path: str,
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:15:1
   |
13 |       - Writes JSON lines to reports/ha_mqtt_trace_snapshot.jsonl (≤150 lines).
14 |     """
15 |     def __init__(self, client, topic_prefix: str, report_path: str,
   | ^^^^
16 |                  max_lines: int = 150, timeout_s: float = 2.0):
17 |         self.client = client
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:16:1
   |
14 |     """
15 |     def __init__(self, client, topic_prefix: str, report_path: str,
16 |                  max_lines: int = 150, timeout_s: float = 2.0):
   | ^^^^^^^^^^^^^^^^^
17 |         self.client = client
18 |         self.topic_prefix = topic_prefix.rstrip("/")
   |

E101 Indentation contains mixed spaces and tabs
  --> ops/evidence/evidence_capture.py:16:1
   |
14 |     """
15 |     def __init__(self, client, topic_prefix: str, report_path: str,
16 |                  max_lines: int = 150, timeout_s: float = 2.0):
   | ^^^^^^^^^^^^^^^^^
17 |         self.client = client
18 |         self.topic_prefix = topic_prefix.rstrip("/")
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:17:1
   |
15 |     def __init__(self, client, topic_prefix: str, report_path: str,
16 |                  max_lines: int = 150, timeout_s: float = 2.0):
17 |         self.client = client
   | ^^^^^^^^
18 |         self.topic_prefix = topic_prefix.rstrip("/")
19 |         self.report_path = report_path
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:18:1
   |
16 |                  max_lines: int = 150, timeout_s: float = 2.0):
17 |         self.client = client
18 |         self.topic_prefix = topic_prefix.rstrip("/")
   | ^^^^^^^^
19 |         self.report_path = report_path
20 |         self.max_lines = max_lines
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:19:1
   |
17 |         self.client = client
18 |         self.topic_prefix = topic_prefix.rstrip("/")
19 |         self.report_path = report_path
   | ^^^^^^^^
20 |         self.max_lines = max_lines
21 |         self.timeout_s = timeout_s
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:20:1
   |
18 |         self.topic_prefix = topic_prefix.rstrip("/")
19 |         self.report_path = report_path
20 |         self.max_lines = max_lines
   | ^^^^^^^^
21 |         self.timeout_s = timeout_s
22 |         self._cmd_q: "queue.Queue[Dict[str, Any]]" = queue.Queue()
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:21:1
   |
19 |         self.report_path = report_path
20 |         self.max_lines = max_lines
21 |         self.timeout_s = timeout_s
   | ^^^^^^^^
22 |         self._cmd_q: "queue.Queue[Dict[str, Any]]" = queue.Queue()
23 |         self._evt_q: "queue.Queue[Dict[str, Any]]" = queue.Queue()
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:22:1
   |
20 |         self.max_lines = max_lines
21 |         self.timeout_s = timeout_s
22 |         self._cmd_q: "queue.Queue[Dict[str, Any]]" = queue.Queue()
   | ^^^^^^^^
23 |         self._evt_q: "queue.Queue[Dict[str, Any]]" = queue.Queue()
24 |         self._stop = threading.Event()
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:23:1
   |
21 |         self.timeout_s = timeout_s
22 |         self._cmd_q: "queue.Queue[Dict[str, Any]]" = queue.Queue()
23 |         self._evt_q: "queue.Queue[Dict[str, Any]]" = queue.Queue()
   | ^^^^^^^^
24 |         self._stop = threading.Event()
25 |         self._t: Optional[threading.Thread] = None
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:24:1
   |
22 |         self._cmd_q: "queue.Queue[Dict[str, Any]]" = queue.Queue()
23 |         self._evt_q: "queue.Queue[Dict[str, Any]]" = queue.Queue()
24 |         self._stop = threading.Event()
   | ^^^^^^^^
25 |         self._t: Optional[threading.Thread] = None
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:25:1
   |
23 |         self._evt_q: "queue.Queue[Dict[str, Any]]" = queue.Queue()
24 |         self._stop = threading.Event()
25 |         self._t: Optional[threading.Thread] = None
   | ^^^^^^^^
26 |
27 |     def start(self):
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:27:1
   |
25 |         self._t: Optional[threading.Thread] = None
26 |
27 |     def start(self):
   | ^^^^
28 |         if self._t and self._t.is_alive(): return
29 |         self._stop.clear()
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:28:1
   |
27 |     def start(self):
28 |         if self._t and self._t.is_alive(): return
   | ^^^^^^^^
29 |         self._stop.clear()
30 |         self._install_callbacks()
   |

E701 Multiple statements on one line (colon)
  --> ops/evidence/evidence_capture.py:28:36
   |
27 |     def start(self):
28 |         if self._t and self._t.is_alive(): return
   |                                          ^
29 |         self._stop.clear()
30 |         self._install_callbacks()
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:29:1
   |
27 |     def start(self):
28 |         if self._t and self._t.is_alive(): return
29 |         self._stop.clear()
   | ^^^^^^^^
30 |         self._install_callbacks()
31 |         self._t = threading.Thread(target=self._runner, name="stp4_evidence", daemon=True)
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:30:1
   |
28 |         if self._t and self._t.is_alive(): return
29 |         self._stop.clear()
30 |         self._install_callbacks()
   | ^^^^^^^^
31 |         self._t = threading.Thread(target=self._runner, name="stp4_evidence", daemon=True)
32 |         self._t.start()
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:31:1
   |
29 |         self._stop.clear()
30 |         self._install_callbacks()
31 |         self._t = threading.Thread(target=self._runner, name="stp4_evidence", daemon=True)
   | ^^^^^^^^
32 |         self._t.start()
   |

E501 Line too long (90 > 88)
  --> ops/evidence/evidence_capture.py:31:83
   |
29 |         self._stop.clear()
30 |         self._install_callbacks()
31 |         self._t = threading.Thread(target=self._runner, name="stp4_evidence", daemon=True)
   |                                                                                         ^^
32 |         self._t.start()
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:32:1
   |
30 |         self._install_callbacks()
31 |         self._t = threading.Thread(target=self._runner, name="stp4_evidence", daemon=True)
32 |         self._t.start()
   | ^^^^^^^^
33 |
34 |     def stop(self):
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:34:1
   |
32 |         self._t.start()
33 |
34 |     def stop(self):
   | ^^^^
35 |         self._stop.set()
36 |         if self._t: self._t.join(timeout=1.0)
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:35:1
   |
34 |     def stop(self):
35 |         self._stop.set()
   | ^^^^^^^^
36 |         if self._t: self._t.join(timeout=1.0)
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:36:1
   |
34 |     def stop(self):
35 |         self._stop.set()
36 |         if self._t: self._t.join(timeout=1.0)
   | ^^^^^^^^
37 |
38 |     def _install_callbacks(self):
   |

E701 Multiple statements on one line (colon)
  --> ops/evidence/evidence_capture.py:36:13
   |
34 |     def stop(self):
35 |         self._stop.set()
36 |         if self._t: self._t.join(timeout=1.0)
   |                   ^
37 |
38 |     def _install_callbacks(self):
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:38:1
   |
36 |         if self._t: self._t.join(timeout=1.0)
37 |
38 |     def _install_callbacks(self):
   | ^^^^
39 |         cmd_topic = f"{self.topic_prefix}/cmd/#"
40 |         state_topic = f"{self.topic_prefix}/state/#"
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:39:1
   |
38 |     def _install_callbacks(self):
39 |         cmd_topic = f"{self.topic_prefix}/cmd/#"
   | ^^^^^^^^
40 |         state_topic = f"{self.topic_prefix}/state/#"
41 |         self.client.subscribe(cmd_topic, qos=1)
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:40:1
   |
38 |     def _install_callbacks(self):
39 |         cmd_topic = f"{self.topic_prefix}/cmd/#"
40 |         state_topic = f"{self.topic_prefix}/state/#"
   | ^^^^^^^^
41 |         self.client.subscribe(cmd_topic, qos=1)
42 |         self.client.subscribe(state_topic, qos=1)
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:41:1
   |
39 |         cmd_topic = f"{self.topic_prefix}/cmd/#"
40 |         state_topic = f"{self.topic_prefix}/state/#"
41 |         self.client.subscribe(cmd_topic, qos=1)
   | ^^^^^^^^
42 |         self.client.subscribe(state_topic, qos=1)
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:42:1
   |
40 |         state_topic = f"{self.topic_prefix}/state/#"
41 |         self.client.subscribe(cmd_topic, qos=1)
42 |         self.client.subscribe(state_topic, qos=1)
   | ^^^^^^^^
43 |
44 |         def on_message(_c, _u, msg):
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:44:1
   |
42 |         self.client.subscribe(state_topic, qos=1)
43 |
44 |         def on_message(_c, _u, msg):
   | ^^^^^^^^
45 |             now = time.time()
46 |             try: payload = msg.payload.decode("utf-8", "ignore")
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:45:1
   |
44 |         def on_message(_c, _u, msg):
45 |             now = time.time()
   | ^^^^^^^^^^^^
46 |             try: payload = msg.payload.decode("utf-8", "ignore")
47 |             except Exception: payload = "<binary>"
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:46:1
   |
44 |         def on_message(_c, _u, msg):
45 |             now = time.time()
46 |             try: payload = msg.payload.decode("utf-8", "ignore")
   | ^^^^^^^^^^^^
47 |             except Exception: payload = "<binary>"
48 |             evt = {"ts": now, "topic": msg.topic, "payload": payload}
   |

E701 Multiple statements on one line (colon)
  --> ops/evidence/evidence_capture.py:46:7
   |
44 |         def on_message(_c, _u, msg):
45 |             now = time.time()
46 |             try: payload = msg.payload.decode("utf-8", "ignore")
   |                ^
47 |             except Exception: payload = "<binary>"
48 |             evt = {"ts": now, "topic": msg.topic, "payload": payload}
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:47:1
   |
45 |             now = time.time()
46 |             try: payload = msg.payload.decode("utf-8", "ignore")
47 |             except Exception: payload = "<binary>"
   | ^^^^^^^^^^^^
48 |             evt = {"ts": now, "topic": msg.topic, "payload": payload}
49 |             (self._cmd_q if "/cmd/" in msg.topic else self._evt_q).put(evt)
   |

E701 Multiple statements on one line (colon)
  --> ops/evidence/evidence_capture.py:47:20
   |
45 |             now = time.time()
46 |             try: payload = msg.payload.decode("utf-8", "ignore")
47 |             except Exception: payload = "<binary>"
   |                             ^
48 |             evt = {"ts": now, "topic": msg.topic, "payload": payload}
49 |             (self._cmd_q if "/cmd/" in msg.topic else self._evt_q).put(evt)
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:48:1
   |
46 |             try: payload = msg.payload.decode("utf-8", "ignore")
47 |             except Exception: payload = "<binary>"
48 |             evt = {"ts": now, "topic": msg.topic, "payload": payload}
   | ^^^^^^^^^^^^
49 |             (self._cmd_q if "/cmd/" in msg.topic else self._evt_q).put(evt)
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:49:1
   |
47 |             except Exception: payload = "<binary>"
48 |             evt = {"ts": now, "topic": msg.topic, "payload": payload}
49 |             (self._cmd_q if "/cmd/" in msg.topic else self._evt_q).put(evt)
   | ^^^^^^^^^^^^
50 |
51 |         old = getattr(self.client, "on_message", None)
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:51:1
   |
49 |             (self._cmd_q if "/cmd/" in msg.topic else self._evt_q).put(evt)
50 |
51 |         old = getattr(self.client, "on_message", None)
   | ^^^^^^^^
52 |         def chained(client, userdata, msg):
53 |             if callable(old):
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:52:1
   |
51 |         old = getattr(self.client, "on_message", None)
52 |         def chained(client, userdata, msg):
   | ^^^^^^^^
53 |             if callable(old):
54 |                 try: old(client, userdata, msg)
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:53:1
   |
51 |         old = getattr(self.client, "on_message", None)
52 |         def chained(client, userdata, msg):
53 |             if callable(old):
   | ^^^^^^^^^^^^
54 |                 try: old(client, userdata, msg)
55 |                 except Exception: pass
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:54:1
   |
52 |         def chained(client, userdata, msg):
53 |             if callable(old):
54 |                 try: old(client, userdata, msg)
   | ^^^^^^^^^^^^^^^^
55 |                 except Exception: pass
56 |             on_message(client, userdata, msg)
   |

E701 Multiple statements on one line (colon)
  --> ops/evidence/evidence_capture.py:54:8
   |
52 |         def chained(client, userdata, msg):
53 |             if callable(old):
54 |                 try: old(client, userdata, msg)
   |                    ^
55 |                 except Exception: pass
56 |             on_message(client, userdata, msg)
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:55:1
   |
53 |             if callable(old):
54 |                 try: old(client, userdata, msg)
55 |                 except Exception: pass
   | ^^^^^^^^^^^^^^^^
56 |             on_message(client, userdata, msg)
57 |         self.client.on_message = chained
   |

E701 Multiple statements on one line (colon)
  --> ops/evidence/evidence_capture.py:55:21
   |
53 |             if callable(old):
54 |                 try: old(client, userdata, msg)
55 |                 except Exception: pass
   |                                 ^
56 |             on_message(client, userdata, msg)
57 |         self.client.on_message = chained
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:56:1
   |
54 |                 try: old(client, userdata, msg)
55 |                 except Exception: pass
56 |             on_message(client, userdata, msg)
   | ^^^^^^^^^^^^
57 |         self.client.on_message = chained
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:57:1
   |
55 |                 except Exception: pass
56 |             on_message(client, userdata, msg)
57 |         self.client.on_message = chained
   | ^^^^^^^^
58 |
59 |     def _runner(self):
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:59:1
   |
57 |         self.client.on_message = chained
58 |
59 |     def _runner(self):
   | ^^^^
60 |         lines = 0
61 |         os.makedirs(os.path.dirname(self.report_path), exist_ok=True)
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:60:1
   |
59 |     def _runner(self):
60 |         lines = 0
   | ^^^^^^^^
61 |         os.makedirs(os.path.dirname(self.report_path), exist_ok=True)
62 |         out = open(self.report_path, "a", encoding="utf-8")
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:61:1
   |
59 |     def _runner(self):
60 |         lines = 0
61 |         os.makedirs(os.path.dirname(self.report_path), exist_ok=True)
   | ^^^^^^^^
62 |         out = open(self.report_path, "a", encoding="utf-8")
63 |         try:
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:62:1
   |
60 |         lines = 0
61 |         os.makedirs(os.path.dirname(self.report_path), exist_ok=True)
62 |         out = open(self.report_path, "a", encoding="utf-8")
   | ^^^^^^^^
63 |         try:
64 |             while not self._stop.is_set() and lines < self.max_lines:
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:63:1
   |
61 |         os.makedirs(os.path.dirname(self.report_path), exist_ok=True)
62 |         out = open(self.report_path, "a", encoding="utf-8")
63 |         try:
   | ^^^^^^^^
64 |             while not self._stop.is_set() and lines < self.max_lines:
65 |                 try: cmd = self._cmd_q.get(timeout=0.5)
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:64:1
   |
62 |         out = open(self.report_path, "a", encoding="utf-8")
63 |         try:
64 |             while not self._stop.is_set() and lines < self.max_lines:
   | ^^^^^^^^^^^^
65 |                 try: cmd = self._cmd_q.get(timeout=0.5)
66 |                 except queue.Empty: continue
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:65:1
   |
63 |         try:
64 |             while not self._stop.is_set() and lines < self.max_lines:
65 |                 try: cmd = self._cmd_q.get(timeout=0.5)
   | ^^^^^^^^^^^^^^^^
66 |                 except queue.Empty: continue
67 |                 deadline = cmd["ts"] + self.timeout_s
   |

E701 Multiple statements on one line (colon)
  --> ops/evidence/evidence_capture.py:65:8
   |
63 |         try:
64 |             while not self._stop.is_set() and lines < self.max_lines:
65 |                 try: cmd = self._cmd_q.get(timeout=0.5)
   |                    ^
66 |                 except queue.Empty: continue
67 |                 deadline = cmd["ts"] + self.timeout_s
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:66:1
   |
64 |             while not self._stop.is_set() and lines < self.max_lines:
65 |                 try: cmd = self._cmd_q.get(timeout=0.5)
66 |                 except queue.Empty: continue
   | ^^^^^^^^^^^^^^^^
67 |                 deadline = cmd["ts"] + self.timeout_s
68 |                 echo = None
   |

E701 Multiple statements on one line (colon)
  --> ops/evidence/evidence_capture.py:66:23
   |
64 |             while not self._stop.is_set() and lines < self.max_lines:
65 |                 try: cmd = self._cmd_q.get(timeout=0.5)
66 |                 except queue.Empty: continue
   |                                   ^
67 |                 deadline = cmd["ts"] + self.timeout_s
68 |                 echo = None
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:67:1
   |
65 |                 try: cmd = self._cmd_q.get(timeout=0.5)
66 |                 except queue.Empty: continue
67 |                 deadline = cmd["ts"] + self.timeout_s
   | ^^^^^^^^^^^^^^^^
68 |                 echo = None
69 |                 while time.time() < deadline:
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:68:1
   |
66 |                 except queue.Empty: continue
67 |                 deadline = cmd["ts"] + self.timeout_s
68 |                 echo = None
   | ^^^^^^^^^^^^^^^^
69 |                 while time.time() < deadline:
70 |                     try: evt = self._evt_q.get(timeout=deadline - time.time())
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:69:1
   |
67 |                 deadline = cmd["ts"] + self.timeout_s
68 |                 echo = None
69 |                 while time.time() < deadline:
   | ^^^^^^^^^^^^^^^^
70 |                     try: evt = self._evt_q.get(timeout=deadline - time.time())
71 |                     except queue.Empty: break
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:70:1
   |
68 |                 echo = None
69 |                 while time.time() < deadline:
70 |                     try: evt = self._evt_q.get(timeout=deadline - time.time())
   | ^^^^^^^^^^^^^^^^^^^^
71 |                     except queue.Empty: break
72 |                     if evt["topic"].split("/")[-1] == cmd["topic"].split("/")[-1]:
   |

E701 Multiple statements on one line (colon)
  --> ops/evidence/evidence_capture.py:70:9
   |
68 |                 echo = None
69 |                 while time.time() < deadline:
70 |                     try: evt = self._evt_q.get(timeout=deadline - time.time())
   |                        ^
71 |                     except queue.Empty: break
72 |                     if evt["topic"].split("/")[-1] == cmd["topic"].split("/")[-1]:
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:71:1
   |
69 |                 while time.time() < deadline:
70 |                     try: evt = self._evt_q.get(timeout=deadline - time.time())
71 |                     except queue.Empty: break
   | ^^^^^^^^^^^^^^^^^^^^
72 |                     if evt["topic"].split("/")[-1] == cmd["topic"].split("/")[-1]:
73 |                         echo = evt; break
   |

E701 Multiple statements on one line (colon)
  --> ops/evidence/evidence_capture.py:71:24
   |
69 |                 while time.time() < deadline:
70 |                     try: evt = self._evt_q.get(timeout=deadline - time.time())
71 |                     except queue.Empty: break
   |                                       ^
72 |                     if evt["topic"].split("/")[-1] == cmd["topic"].split("/")[-1]:
73 |                         echo = evt; break
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:72:1
   |
70 |                     try: evt = self._evt_q.get(timeout=deadline - time.time())
71 |                     except queue.Empty: break
72 |                     if evt["topic"].split("/")[-1] == cmd["topic"].split("/")[-1]:
   | ^^^^^^^^^^^^^^^^^^^^
73 |                         echo = evt; break
74 |                 record = {
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:73:1
   |
71 |                     except queue.Empty: break
72 |                     if evt["topic"].split("/")[-1] == cmd["topic"].split("/")[-1]:
73 |                         echo = evt; break
   | ^^^^^^^^^^^^^^^^^^^^^^^^
74 |                 record = {
75 |                     "phase": "STP4",
   |

E702 Multiple statements on one line (semicolon)
  --> ops/evidence/evidence_capture.py:73:17
   |
71 |                     except queue.Empty: break
72 |                     if evt["topic"].split("/")[-1] == cmd["topic"].split("/")[-1]:
73 |                         echo = evt; break
   |                                   ^
74 |                 record = {
75 |                     "phase": "STP4",
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:74:1
   |
72 |                     if evt["topic"].split("/")[-1] == cmd["topic"].split("/")[-1]:
73 |                         echo = evt; break
74 |                 record = {
   | ^^^^^^^^^^^^^^^^
75 |                     "phase": "STP4",
76 |                     "cmd": cmd,
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:75:1
   |
73 |                         echo = evt; break
74 |                 record = {
75 |                     "phase": "STP4",
   | ^^^^^^^^^^^^^^^^^^^^
76 |                     "cmd": cmd,
77 |                     "echo": echo,
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:76:1
   |
74 |                 record = {
75 |                     "phase": "STP4",
76 |                     "cmd": cmd,
   | ^^^^^^^^^^^^^^^^^^^^
77 |                     "echo": echo,
78 |                     "latency_ms": int((echo["ts"] - cmd["ts"]) * 1000) if echo else None,
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:77:1
   |
75 |                     "phase": "STP4",
76 |                     "cmd": cmd,
77 |                     "echo": echo,
   | ^^^^^^^^^^^^^^^^^^^^
78 |                     "latency_ms": int((echo["ts"] - cmd["ts"]) * 1000) if echo else None,
79 |                     "result": "PASS" if echo else "FAIL"
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:78:1
   |
76 |                     "cmd": cmd,
77 |                     "echo": echo,
78 |                     "latency_ms": int((echo["ts"] - cmd["ts"]) * 1000) if echo else None,
   | ^^^^^^^^^^^^^^^^^^^^
79 |                     "result": "PASS" if echo else "FAIL"
80 |                 }
   |

E501 Line too long (89 > 88)
  --> ops/evidence/evidence_capture.py:78:74
   |
76 |                     "cmd": cmd,
77 |                     "echo": echo,
78 |                     "latency_ms": int((echo["ts"] - cmd["ts"]) * 1000) if echo else None,
   |                                                                                         ^
79 |                     "result": "PASS" if echo else "FAIL"
80 |                 }
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:79:1
   |
77 |                     "echo": echo,
78 |                     "latency_ms": int((echo["ts"] - cmd["ts"]) * 1000) if echo else None,
79 |                     "result": "PASS" if echo else "FAIL"
   | ^^^^^^^^^^^^^^^^^^^^
80 |                 }
81 |                 out.write(json.dumps(record, ensure_ascii=False) + "\n"); out.flush()
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:80:1
   |
78 |                     "latency_ms": int((echo["ts"] - cmd["ts"]) * 1000) if echo else None,
79 |                     "result": "PASS" if echo else "FAIL"
80 |                 }
   | ^^^^^^^^^^^^^^^^
81 |                 out.write(json.dumps(record, ensure_ascii=False) + "\n"); out.flush()
82 |                 lines += 1
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:81:1
   |
79 |                     "result": "PASS" if echo else "FAIL"
80 |                 }
81 |                 out.write(json.dumps(record, ensure_ascii=False) + "\n"); out.flush()
   | ^^^^^^^^^^^^^^^^
82 |                 lines += 1
83 |         finally:
   |

E702 Multiple statements on one line (semicolon)
  --> ops/evidence/evidence_capture.py:81:61
   |
79 |                     "result": "PASS" if echo else "FAIL"
80 |                 }
81 |                 out.write(json.dumps(record, ensure_ascii=False) + "\n"); out.flush()
   |                                                                         ^
82 |                 lines += 1
83 |         finally:
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:82:1
   |
80 |                 }
81 |                 out.write(json.dumps(record, ensure_ascii=False) + "\n"); out.flush()
82 |                 lines += 1
   | ^^^^^^^^^^^^^^^^
83 |         finally:
84 |             out.close()
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:83:1
   |
81 |                 out.write(json.dumps(record, ensure_ascii=False) + "\n"); out.flush()
82 |                 lines += 1
83 |         finally:
   | ^^^^^^^^
84 |             out.close()
   |

W191 Indentation contains tabs
  --> ops/evidence/evidence_capture.py:84:1
   |
82 |                 lines += 1
83 |         finally:
84 |             out.close()
   | ^^^^^^^^^^^^
   |

I001 [*] Import block is un-sorted or un-formatted
 --> ops/test_facade_attach_mqtt.py:1:1
  |
1 | / from types import SimpleNamespace
2 | | from bb8_core.facade import BB8Facade
  | |_____________________________________^
3 |   class FakeClient:
4 |       def __init__(self): self.calls=[]
  |
help: Organize imports

I001 [*] Import block is un-sorted or un-formatted
 --> ops/test_logging_fallback.py:1:1
  |
1 | / import os
2 | | from bb8_core.logging_setup import init_file_handler, logger
  | |____________________________________________________________^
3 |   h=init_file_handler()
4 |   logger.addHandler(h)
  |
help: Organize imports

F401 [*] `os` imported but unused
 --> ops/test_logging_fallback.py:1:8
  |
1 | import os
  |        ^^
2 | from bb8_core.logging_setup import init_file_handler, logger
3 | h=init_file_handler()
  |
help: Remove unused import: `os`

I001 [*] Import block is un-sorted or un-formatted
  --> scan_bb8_gatt.py:8:1
   |
 6 |   ╚═════════════════════════════════════════════════════════════════════╝
 7 |   """
 8 | / import argparse
 9 | | import asyncio
10 | | from bleak import BleakScanner, BleakClient
   | |___________________________________________^
11 |
12 |   async def main(adapter, bb8_name):
   |
help: Organize imports

E501 Line too long (89 > 88)
  --> scan_bb8_gatt.py:24:89
   |
22 |             # Fallback: pick first Sphero/SpheroBB type device
23 |             for d in scanner.discovered_devices:
24 |                 if "sphero" in (d.name or "").lower() or "bb8" in (d.name or "").lower():
   |                                                                                         ^
25 |                     device = d
26 |                     break
   |

E501 Line too long (99 > 88)
  --> scan_bb8_gatt.py:28:89
   |
26 |                     break
27 |     if not device:
28 |         print("BB-8 not found. Is it awake and advertising? Try tapping or removing from charger.")
   |                                                                                         ^^^^^^^^^^^
29 |         return
   |

E501 Line too long (99 > 88)
  --> scan_bb8_gatt.py:38:89
   |
36 |             for char in service.characteristics:
37 |                 props = ','.join(char.properties)
38 |                 print(f"  [Characteristic] {char.uuid} | {char.description} | properties: {props}")
   |                                                                                         ^^^^^^^^^^^
39 |
40 | if __name__ == "__main__":
   |

E501 Line too long (93 > 88)
  --> scan_bb8_gatt.py:42:89
   |
40 | if __name__ == "__main__":
41 |     parser = argparse.ArgumentParser(description="Scan BB-8 BLE GATT Characteristics")
42 |     parser.add_argument("--adapter", default="hci0", help="BLE adapter name (default: hci0)")
   |                                                                                         ^^^^^
43 |     parser.add_argument("--bb8_name", default="BB-8", help="Name fragment to identify BB-8 (default: BB-8)")
44 |     args = parser.parse_args()
   |

E501 Line too long (108 > 88)
  --> scan_bb8_gatt.py:43:89
   |
41 |     parser = argparse.ArgumentParser(description="Scan BB-8 BLE GATT Characteristics")
42 |     parser.add_argument("--adapter", default="hci0", help="BLE adapter name (default: hci0)")
43 |     parser.add_argument("--bb8_name", default="BB-8", help="Name fragment to identify BB-8 (default: BB-8)")
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^
44 |     args = parser.parse_args()
   |

I001 [*] Import block is un-sorted or un-formatted
 --> tests/test_ble_link.py:1:1
  |
1 | / import threading
2 | | import time
3 | | from bb8_core.ble_link import BLELink
  | |_____________________________________^
4 |
5 |   def test_ble_link_thread_lifecycle():
  |
help: Organize imports

F401 [*] `threading` imported but unused
 --> tests/test_ble_link.py:1:8
  |
1 | import threading
  |        ^^^^^^^^^
2 | import time
3 | from bb8_core.ble_link import BLELink
  |
help: Remove unused import: `threading`

I001 [*] Import block is un-sorted or un-formatted
 --> tests/test_discovery_publisher.py:1:1
  |
1 | / import os
2 | | import unittest
3 | | from unittest.mock import patch, MagicMock
  | |__________________________________________^
4 |
5 |   class TestDiscoveryPublisher(unittest.TestCase):
  |
help: Organize imports

E501 Line too long (123 > 88)
  --> tests/test_discovery_publisher.py:8:89
   |
 6 |     @patch("bb8_core.bb8_presence_scanner.publish_discovery")
 7 |     @patch("bb8_core.mqtt_dispatcher.publish_discovery")
 8 |     def test_scanner_only_discovery_when_bridge_telemetry_enabled(self, mock_dispatcher_discovery, mock_scanner_discovery):
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 9 |         # Set environment/config to enable bridge telemetry
10 |         os.environ["ENABLE_BRIDGE_TELEMETRY"] = "1"
   |

I001 [*] Import block is un-sorted or un-formatted
 --> tests/test_facade.py:1:1
  |
1 | / import time
2 | |
3 | | from bb8_core.facade import Bb8Facade, Rgb
  | |__________________________________________^
4 |
5 |   class StubCore:
  |
help: Organize imports

N812 Lowercase `facade` imported as non-lowercase `F`
  --> tests/test_facade.py:21:12
   |
20 | def test_sleep_mapping(monkeypatch):
21 |     import bb8_core.facade as F
   |            ^^^^^^^^^^^^^^^^^^^^
22 |     monkeypatch.setattr(F, "Core", StubCore)
23 |     StubCore.calls.clear()
   |

N812 Lowercase `facade` imported as non-lowercase `F`
  --> tests/test_facade.py:29:12
   |
28 | def test_led_set_immediate(monkeypatch):
29 |     import bb8_core.facade as F
   |            ^^^^^^^^^^^^^^^^^^^^
30 |     monkeypatch.setattr(F, "Core", StubCore)
31 |     StubCore.calls.clear()
   |

N812 Lowercase `facade` imported as non-lowercase `F`
  --> tests/test_facade.py:38:12
   |
37 | def test_led_fade_steps(monkeypatch):
38 |     import bb8_core.facade as F
   |            ^^^^^^^^^^^^^^^^^^^^
39 |     monkeypatch.setattr(F, "Core", StubCore)
40 |     StubCore.calls.clear()
   |

E501 Line too long (100 > 88)
  --> tests/test_facade.py:42:89
   |
40 |     StubCore.calls.clear()
41 |     slept = {"ms": 0}
42 |     monkeypatch.setattr(time, "sleep", lambda s: slept.__setitem__("ms", slept["ms"] + int(s*1000)))
   |                                                                                         ^^^^^^^^^^^^
43 |     f = Bb8Facade(toy=object())
44 |     f.set_led(Rgb(10, 0, 0), transition_ms=100, steps=5)
   |

N812 Lowercase `facade` imported as non-lowercase `F`
  --> tests/test_facade.py:51:12
   |
50 | def test_drive_autostop(monkeypatch):
51 |     import bb8_core.facade as F
   |            ^^^^^^^^^^^^^^^^^^^^
52 |     monkeypatch.setattr(F, "Core", StubCore)
53 |     StubCore.calls.clear()
   |

I001 [*] Import block is un-sorted or un-formatted
 --> tests/test_mqtt_dispatcher.py:1:1
  |
1 | / import threading
2 | | import time
3 | | import json
4 | | from unittest.mock import MagicMock, patch
5 | | import paho.mqtt.client as mqtt # pyright: ignore[reportMissingImports]
6 | | from bb8_core.logging_setup import logger
  | |_________________________________________^
7 |
8 |   # Test parameters
  |
help: Organize imports

F401 [*] `unittest.mock.MagicMock` imported but unused
 --> tests/test_mqtt_dispatcher.py:4:27
  |
2 | import time
3 | import json
4 | from unittest.mock import MagicMock, patch
  |                           ^^^^^^^^^
5 | import paho.mqtt.client as mqtt # pyright: ignore[reportMissingImports]
6 | from bb8_core.logging_setup import logger
  |
help: Remove unused import: `unittest.mock.MagicMock`

E501 Line too long (98 > 88)
  --> tests/test_mqtt_dispatcher.py:17:89
   |
15 | class MockController:
16 |     def handle_command(self, command, payload):
17 |         logger.info({"event": "test_mock_handle_command", "command": command, "payload": payload})
   |                                                                                         ^^^^^^^^^^
18 |         return "mock-dispatched"
   |

I001 [*] Import block is un-sorted or un-formatted
 --> tests/test_mqtt_echo.py:1:1
  |
1 | / import json
2 | | import pytest
3 | | from bb8_core.mqtt_echo import echo_scalar, echo_led
  | |____________________________________________________^
4 |
5 |   class FakeMQTT:
  |
help: Organize imports

I001 [*] Import block is un-sorted or un-formatted
 --> tests/test_mqtt_smoke.py:1:1
  |
1 | / import json
2 | | import pytest
3 | | from bb8_core.mqtt_dispatcher import start_mqtt_dispatcher
4 | | from bb8_core.discovery_publish import publish_discovery
5 | | from bb8_core.facade import Bb8Facade, Rgb
  | |__________________________________________^
6 |
7 |   class FakeMQTT:
  |
help: Organize imports

F401 [*] `pytest` imported but unused
 --> tests/test_mqtt_smoke.py:2:8
  |
1 | import json
2 | import pytest
  |        ^^^^^^
3 | from bb8_core.mqtt_dispatcher import start_mqtt_dispatcher
4 | from bb8_core.discovery_publish import publish_discovery
  |
help: Remove unused import: `pytest`

F401 [*] `bb8_core.facade.Bb8Facade` imported but unused
 --> tests/test_mqtt_smoke.py:5:29
  |
3 | from bb8_core.mqtt_dispatcher import start_mqtt_dispatcher
4 | from bb8_core.discovery_publish import publish_discovery
5 | from bb8_core.facade import Bb8Facade, Rgb
  |                             ^^^^^^^^^
6 |
7 | class FakeMQTT:
  |
help: Remove unused import

F401 [*] `bb8_core.facade.Rgb` imported but unused
 --> tests/test_mqtt_smoke.py:5:40
  |
3 | from bb8_core.mqtt_dispatcher import start_mqtt_dispatcher
4 | from bb8_core.discovery_publish import publish_discovery
5 | from bb8_core.facade import Bb8Facade, Rgb
  |                                        ^^^
6 |
7 | class FakeMQTT:
  |
help: Remove unused import

E701 Multiple statements on one line (colon)
  --> tests/test_mqtt_smoke.py:27:14
   |
25 |         self.entries.append(("error", msg))
26 |
27 | class FakeToy: pass
   |              ^
28 |
29 | def test_discovery_and_dispatcher_smoke():
   |

E501 Line too long (112 > 88)
  --> tests/test_mqtt_smoke.py:53:89
   |
51 |     mqtt.trigger(f"bb8/{device_id}/cmd/sleep", json.dumps({"after_ms": 0}))
52 |     # Simulate drive
53 |     mqtt.trigger(f"bb8/{device_id}/cmd/drive", json.dumps({"heading_deg": 90, "speed": 100, "duration_ms": 10}))
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^
54 |     # Validate state echo
55 |     assert any(f"bb8/{device_id}/state/led" in t for t, *_ in mqtt.published)
   |

I001 [*] Import block is un-sorted or un-formatted
 --> tests/test_smoke_controller_facade.py:2:1
  |
1 | # tests/test_smoke_controller_facade.py
2 | import unittest
  | ^^^^^^^^^^^^^^^
3 |
4 | class TestSmokeControllerFacade(unittest.TestCase):
  |
help: Organize imports

F841 Local variable `dummy_cfg` is assigned to but never used
  --> tests/test_smoke_controller_facade.py:10:9
   |
 8 |         from bb8_core.facade import BB8Facade
 9 |         # Construct dummy config and bridge
10 |         dummy_cfg = {"bb8_mac": "ED:ED:87:D7:27:50", "ble_adapter": "hci0"}
   |         ^^^^^^^^^
11 |         class DummyBridge:
12 |             pass
   |
help: Remove assignment to unused variable `dummy_cfg`

E401 [*] Multiple imports on one line
 --> tools/strict_trace_check.py:2:1
  |
1 | # tools/strict_trace_check.py
2 | import json, sys, re, pathlib
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
3 |
4 | p = pathlib.Path(sys.argv[1])
  |
help: Split imports

I001 [*] Import block is un-sorted or un-formatted
 --> tools/strict_trace_check.py:2:1
  |
1 | # tools/strict_trace_check.py
2 | import json, sys, re, pathlib
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
3 |
4 | p = pathlib.Path(sys.argv[1])
  |
help: Organize imports

F401 [*] `re` imported but unused
 --> tools/strict_trace_check.py:2:19
  |
1 | # tools/strict_trace_check.py
2 | import json, sys, re, pathlib
  |                   ^^
3 |
4 | p = pathlib.Path(sys.argv[1])
  |
help: Remove unused import: `re`

E501 Line too long (100 > 88)
  --> tools/trace_smoke_check.py:14:89
   |
12 |         print(f"Reports directory not found: {reports_dir}")
13 |         sys.exit(1)
14 |     subfolders = [f for f in os.listdir(reports_dir) if os.path.isdir(os.path.join(reports_dir, f))]
   |                                                                                         ^^^^^^^^^^^^
15 |     if not subfolders:
16 |         print(f"No subfolders found in reports directory: {reports_dir}")
   |

E501 Line too long (121 > 88)
  --> tools/trace_smoke_check.py:55:89
   |
53 | found_device_scalar = False
54 | for entry in lines:
55 |     if isinstance(entry, dict) and entry.get("source") == "device" and isinstance(entry.get("value"), (int, float, str)):
   |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
56 |         found_device_scalar = True
57 |         break
   |

Found 624 errors.
[*] 118 fixable with the `--fix` option (6 hidden fixes can be enabled with the `--unsafe-fixes` option).
