## 1. Audit of Recent Changes

### A. Switch to `CallbackAPIVersion.VERSION2`
- **Impact:** VERSION2 enforces stricter callback signatures (e.g., `on_message`, `on_connect`, etc. require an extra `properties` argument). If any callback is missing this argument, paho-mqtt will raise exceptions, potentially causing reconnect loops, thread leaks, or unhandled errors that accumulate and exhaust memory.
- **Risk:** Signature mismatches can cause the MQTT client to fail silently, retry, or spawn new threads, leading to OOM.

### B. Removal of `warnings.filterwarnings`
- **Impact:** No direct memory impact, but previously, warning suppression may have masked signature mismatches or deprecated usage. Now, errors are surfaced, but if not handled, can cause instability.
- **Risk:** Unhandled warnings are less of a direct OOM risk, but their underlying causes (e.g., API misuse) are.

### C. Threading, Rate Limits, Inflight Semaphore Logic
- **Impact:** If callback errors cause the MQTT client to disconnect/reconnect rapidly, or if threads are spawned per connection attempt, this can quickly exhaust system resources.
- **Risk:** Any logic that creates threads or semaphores per connection, without proper cleanup, can cause leaks.

---

## 2. Analysis & Identification

- **Signature Mismatches:** Audit all MQTT callback functions (`on_connect`, `on_message`, etc.) for correct VERSION2 signatures.
- **Thread/Resource Leaks:** Check for logic that spawns threads or semaphores on connect/reconnect, especially in error handling or callback exceptions.
- **Reconnect Loops:** Look for code that reconnects on error without backoff or limit.

---

## 3. Patch Plan

### Step 1: Audit and Fix Callback Signatures

**Action:** Update all MQTT callback functions to match VERSION2 requirements.

**Required Signature Example:**
```python
def on_connect(client, userdata, flags, rc, properties=None):
    # ...existing code...
def on_message(client, userdata, msg):
    # ...existing code...
```
- For VERSION2, `on_connect` must accept `properties`; other callbacks may also require changes.

**Files to Audit:**  
- echo_responder.py
- mqtt_dispatcher.py
- force_discovery_emit.py
- check_bridge_broker.py
- discovery_migrate.py
- smoke_handlers.py
- Any other file instantiating `mqtt.Client`

---

### Step 2: Add Runtime Checks for Callback Compatibility

**Action:** Add a test or runtime assertion to verify all MQTT callbacks have the correct signature.

**Example:**
```python
import inspect

def verify_callback_signature(callback, required_args):
    sig = inspect.signature(callback)
    params = list(sig.parameters)
    assert all(arg in params for arg in required_args), f"Callback {callback.__name__} missing required args: {required_args}"

# Usage:
verify_callback_signature(on_connect, ["client", "userdata", "flags", "rc", "properties"])
```

---

### Step 3: Review and Refactor Threading/Resource Logic

**Action:** Audit all places where threads, semaphores, or rate limits are managed. Ensure:
- No thread is spawned per reconnect without cleanup.
- Inflight semaphores are released on disconnect/error.
- Reconnect logic uses exponential backoff or limits.

**Example Fix:**
```python
# Add exponential backoff to reconnect logic
import time

def reconnect_with_backoff(client, max_attempts=5):
    delay = 1
    for attempt in range(max_attempts):
        try:
            client.reconnect()
            break
        except Exception:
            time.sleep(delay)
            delay = min(delay * 2, 60)
```

---

### Step 4: Revert or Update Callback API Usage

**Action:** If callback signatures cannot be updated everywhere, revert to `CallbackAPIVersion.VERSION1` for stability, and reinstate warning suppression as a temporary measure.

**Example:**
```python
client = mqtt.Client(callback_api_version=CallbackAPIVersion.VERSION1)
import warnings
warnings.filterwarnings("ignore", "Callback API version 1 is deprecated", DeprecationWarning)
```

---

### Step 5: Add Tests for Thread/Memory Leaks

**Action:** Add pytest tests to monitor thread count and memory usage before/after MQTT client operations.

**Example:**
```python
import threading
import psutil

def test_no_thread_leak():
    before = threading.active_count()
    # ...run MQTT connect/disconnect...
    after = threading.active_count()
    assert after - before < 2, "Thread leak detected"

def test_no_memory_leak():
    process = psutil.Process()
    before = process.memory_info().rss
    # ...run MQTT operations...
    after = process.memory_info().rss
    assert after - before < 10 * 1024 * 1024, "Memory leak detected"
```

---

### Step 6: Documentation and Future-Proofing

**Action:**  
- Update documentation to specify required callback signatures for each API version.
- Add a checklist for auditing callback compatibility on future upgrades.
- Maintain a test that fails if callback signatures are incorrect or if thread/memory leaks are detected.

---

## 4. Recommendations

- **Always audit callback signatures when upgrading paho-mqtt API version.**
- **Avoid module-level instantiation of `mqtt.Client`; prefer inside functions/classes.**
- **Implement exponential backoff and limits on reconnect logic.**
- **Monitor thread and memory usage in CI.**
- **Document all API version dependencies and required callback signatures.**
- **Reinstate warning suppression only as a last resort for stability, and document the reason.**

---

## 5. Step-by-Step Code Changes

1. **Audit and fix all MQTT callback signatures to match VERSION2.**
2. **Add runtime checks for callback compatibility.**
3. **Review and refactor threading/reconnect logic for leaks and runaway loops.**
4. **If needed, revert to VERSION1 and reinstate warning suppression.**
5. **Add tests for thread/memory leaks.**
6. **Update documentation and add future-proofing checklists.**

---