#══════════════════════════════════════════════════════════════════════════════
# ⟫⟫ PLEX LIBRARY  •  Interactive Show/Movie Selectors + Routing
# ⟫⟫ package_plex.yaml  •  packages: !include_dir_named packages
# ⟫⟫ Tier: γ  •  Domain: media  •  Created: 2025-08-10
#══════════════════════════════════════════════════════════════════════════════

# ═══ SENSORS (REST -> JSON) ═══

# ═══ REST COMMANDS (no entities created, no recorder writes) ═══
rest_command:
  plex_fetch_shows:
    url: "http://192.168.0.104:32400/library/sections/7/all?type=2&sort=titleSort:asc&X-Plex-Container-Start=0&X-Plex-Container-Size=2000"
    method: GET
    headers:
      Accept: application/json
      X-Plex-Token: !secret PLEX_TOKEN

  plex_fetch_movies:
    url: "http://192.168.0.104:32400/library/sections/8/all?type=1&sort=titleSort:asc&X-Plex-Container-Start=0&X-Plex-Container-Size=2000"
    method: GET
    headers:
      Accept: application/json
      X-Plex-Token: !secret PLEX_TOKEN

  plex_fetch_movies_recent:
    url: "http://192.168.0.104:32400/library/sections/8/all?type=1&sort=addedAt:desc&X-Plex-Container-Start=0&X-Plex-Container-Size=30"
    method: GET
    headers:
      Accept: application/json
      X-Plex-Token: !secret PLEX_TOKEN

# ═══ HELPERS (Reference only - managed via GUI) ═══

# ═══ SCRIPTS (refresh + route/open Plex) ═══
script:
  plex_refresh_library_indexes:
    alias: "Plex – Refresh Indexes (Variables)"
    sequence:
      # 1) Fetch
      - action: rest_command.plex_fetch_shows
        response_variable: shows_resp
      - action: rest_command.plex_fetch_movies
        response_variable: movies_resp

      # 2) Parse JSON in memory (robust to empty/non-JSON responses)
      - variables:
          # Shows JSON (handle dict or string)
          shows_json: >-
            {% set raw = shows_resp.content if shows_resp is defined and 'content' in shows_resp else '' %}
            {% if raw is mapping %}
              {{ raw }}
            {% else %}
              {% set b = (raw if raw is string else '') | trim %}
              {{ (b if (b|length > 0 and (b[0] in ['{','['])) else '{}') | from_json }}
            {% endif %}

          # Movies JSON
          movies_json: >-
            {% set raw = movies_resp.content if movies_resp is defined and 'content' in movies_resp else '' %}
            {% if raw is mapping %}
              {{ raw }}
            {% else %}
              {% set b = (raw if raw is string else '') | trim %}
              {{ (b if (b|length > 0 and (b[0] in ['{','['])) else '{}') | from_json }}
            {% endif %}

          shows: "{{ shows_json.get('MediaContainer', {}).get('Metadata', []) }}"
          movies: "{{ movies_json.get('MediaContainer', {}).get('Metadata', []) }}"

          # Compact title lists
          show_titles: "{{ shows | map(attribute='title') | select('string') | unique | list | sort }}"
          movie_titles: "{{ movies | map(attribute='title') | select('string') | unique | list | sort }}"

          # Local TV index (maps + counts) — uses Plex fields: childCount (seasons), leafCount (episodes)
          tv_shows_map_json: >-
            {% set ns = namespace(m={}) %}
            {% for it in shows %}
              {% if it.title is string and it.ratingKey is defined %}
                {% set _ = ns.m.update({ it.title: it.ratingKey }) %}
              {% endif %}
            {% endfor %}
            {{ ns.m | tojson }}
          tv_seasons_counts_json: >-
            {% set ns = namespace(m={}) %}
            {% for it in shows %}
              {% if it.title is string %}
                {% set _ = ns.m.update({ it.title: (it.childCount | default(0)) }) %}
              {% endif %}
            {% endfor %}
            {{ ns.m | tojson }}
          tv_episodes_counts_json: >-
            {% set ns = namespace(m={}) %}
            {% for it in shows %}
              {% if it.title is string %}
                {% set _ = ns.m.update({ it.title: (it.leafCount | default(0)) }) %}
              {% endif %}
            {% endfor %}
            {{ ns.m | tojson }}
          tv_total_episodes: >-
            {% set total = 0 %}
            {% for it in shows %}
              {% set total = total + (it.leafCount | default(0)) %}
            {% endfor %}
            {{ total }}

          # Local Movie index (maps + years)
          movie_map_json: >-
            {% set ns = namespace(m={}) %}
            {% for it in movies %}
              {% if it.title is string and it.ratingKey is defined %}
                {% set _ = ns.m.update({ it.title: it.ratingKey }) %}
              {% endif %}
            {% endfor %}
            {{ ns.m | tojson }}
          movie_years_json: >-
            {% set ns = namespace(m={}) %}
            {% for it in movies %}
              {% if it.title is string and it.year is defined %}
                {% set _ = ns.m.update({ it.title: it.year }) %}
              {% endif %}
            {% endfor %}
            {{ ns.m | tojson }}

      # 3) Save into Variables (attributes are JSON strings; values are totals)
      - action: var.set
        data:
          entity_id: var.plex_tv_index
          value: "{{ tv_total_episodes | int }}"
          attributes:
            shows: "{{ tv_shows_map_json }}"
            seasons: "{{ tv_seasons_counts_json }}"
            episodes: "{{ tv_episodes_counts_json }}"
            updated: "{{ now() }}"
      - action: var.set
        data:
          entity_id: var.plex_movie_index
          value: "{{ movie_titles | count }}"
          attributes:
            movies: "{{ movie_map_json }}"
            year_released: "{{ movie_years_json }}"
            updated: "{{ now() }}"

      # 4) (Optional) update dropdowns if they exist (won’t run if missing)
      - choose:
          - conditions: "{{ states('input_select.plex_show') != 'unknown' }}"
            sequence:
              - action: input_select.set_options
                target: { entity_id: input_select.plex_show }
                data:
                  options: "{{ show_titles }}"
          - conditions: "{{ states('input_select.plex_movie') != 'unknown' }}"
            sequence:
              - action: input_select.set_options
                target: { entity_id: input_select.plex_movie }
                data:
                  options: "{{ movie_titles }}"

  plex_play_selected_movie_localdb:
    alias: "Plex – Play Selected Movie (Local Index)"
    fields:
      plex_client:
        description: "Plex client media_player entity"
        example: media_player.plex_bedroom_apple_tv
    sequence:
      - variables:
          title: "{{ states('input_select.plex_movie') }}"
          movies_map: "{{ state_attr('var.plex_movie_index','movies') | default('{}') | from_json }}"
          rk: "{{ movies_map.get(title) }}"
      - condition: template
        value_template: "{{ rk is string }}"
      - action: media_player.play_media
        target:
          entity_id: "{{ plex_client }}"
        data:
          media_content_type: movie
          media_content_id: "/library/metadata/{{ rk }}"

  plex_refresh_selectors_light:
    alias: "Plex – Refresh Selectors (Light)"
    sequence:
      # Fetch minimal payloads
      - action: rest_command.plex_fetch_shows
        response_variable: shows_resp
      - action: rest_command.plex_fetch_movies_recent
        response_variable: movies_resp

      # Parse ONLY what we need (pure expressions; no {% %} blocks)
      - variables:
          shows_json: "{{ (shows_resp.content | default('{}', true)) | from_json }}"
          movies_json: "{{ (movies_resp.content | default('{}', true)) | from_json }}"

          # Shows: alphabetical (API already sorts by titleSort asc)
          show_titles: >-
            {{
              (shows_json.get('MediaContainer', {}).get('Metadata', [])
               | map(attribute='title') | select('string') | unique | list)
              if shows_json is mapping else []
            }}

          # Movies: 30 most recently added (API provides in desc order)
          movie_titles_recent: >-
            {{
              (movies_json.get('MediaContainer', {}).get('Metadata', [])
               | map(attribute='title') | select('string') | list)
              if movies_json is mapping else []
            }}

      # Push into dropdowns (native lists; no tojson needed)
      - choose:
          - conditions: "{{ states('input_select.plex_show') not in ['unknown','unavailable'] }}"
            sequence:
              - action: input_select.set_options
                target: { entity_id: input_select.plex_show }
                data:
                  options: "{{ show_titles }}"
          - conditions: "{{ states('input_select.plex_movie') not in ['unknown','unavailable'] }}"
            sequence:
              - action: input_select.set_options
                target: { entity_id: input_select.plex_movie }
                data:
                  options: "{{ movie_titles_recent }}"
    mode: single

  # ═══ Route HDMI Matrix to Apple TV and open Plex on Apple TV
  plex_route_and_open_app:
    alias: "Plex – Route to Apple TV & Open Plex"
    sequence:
      - action: script.matrix_control
        data:
          source: "Apple TV"
          remote: remote.bedroom_broadlink_rm3_alpha
          device: bedroom_hdmi_matrix
          tv: media_player.bedroom_tv_alpha
      - action: media_player.select_source
        target:
          entity_id: media_player.bedroom_apple_tv_alpha
        data:
          source: "Plex"

# ═══ AUTOMATIONS (populate selectors from REST JSON) ═══
automation:
  - alias: Plex – Nightly Refresh
    id: 9f8e7d6c-5b4a-3c2d-1e0f-223344556677
    description: "Optional: nightly refresh to keep lists fresh even if idle"
    mode: single
    triggers:
      - trigger: homeassistant
        event: start
      - trigger: time
        at: "03:05:00"
    actions:
      - choose:
          - conditions: "{{ trigger is defined and trigger.platform == 'homeassistant' }}"
            sequence:
              - delay: "00:00:15" # wait 15s on startup
      - action: script.plex_refresh_library_indexes

      # Build a summary from the local variables (no Recorder bloat)
      - variables:
          is_startup: "{{ trigger is defined and trigger.platform == 'homeassistant' }}"

          tv_map: "{{ state_attr('var.plex_tv_index','shows') | default('{}') | from_json }}"
          tv_titles: "{{ tv_map | length }}"
          tv_episodes: "{{ states('var.plex_tv_index') | int(0) }}"

          movie_map: "{{ state_attr('var.plex_movie_index','movies') | default('{}') | from_json }}"
          movies_count: "{{ movie_map | length }}"

          updated_ts: "{{ state_attr('var.plex_tv_index','updated') }}"
          updated_disp: >-
            {% if updated_ts %}{{ as_datetime(updated_ts) }}{% else %}{{ now() }}{% endif %}

          sample_shows: >-
            {% set k = tv_map.keys() | list | sort %}
            {{ (k[:3] | join(', ')) if k|length > 0 else '—' }}
          sample_movies: >-
            {% set k = movie_map.keys() | list | sort %}
            {{ (k[:3] | join(', ')) if k|length > 0 else '—' }}

          ok: "{{ tv_titles > 0 or movies_count > 0 }}"

      - action: persistent_notification.create
        data:
          title: >-
            {{ 'Plex refreshed (Startup)' if is_startup else 'Plex refreshed' }}
          message: >-
            {% if ok -%}
            ✅ Library indexed at {{ updated_disp }}.
            • Shows: **{{ tv_titles }}** ({{ tv_episodes }} episodes)
            • Movies: **{{ movies_count }}**
            {% if tv_titles > 0 %}• e.g., _{{ sample_shows }}_{% endif %}
            {% if movies_count > 0 %}• e.g., _{{ sample_movies }}_{% endif %}
            {%- else -%}
            ⚠️ Library refresh ran but returned no data.
            Check Plex availability, token, or section IDs (TV=7, Movies=8), then retry.
            {%- endif %}
          notification_id: plex_refresh_status
# ═══ DASHBOARD COMPONENTS ═══
# type: grid
# columns: 3
# square: false
# cards:
#   - type: entities
#    title: Plex – Choose Show
#     entities: [input_select.plex_show]
#   - type: entities
#     title: Plex – Choose Movie
#    entities: [input_select.plex_movie]
#  - type: button
#    name: Refresh Lists
#    icon: mdi:refresh
#    tap_action:
#      action: perform-action
#      perform_action: script.plex_refresh_library_lists
